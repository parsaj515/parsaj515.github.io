<!doctypehtml><html lang=en><meta charset=UTF-8><meta content="width=device-width,initial-scale=1,viewport-fit=cover"name=viewport><meta content=yes name=apple-mobile-web-app-capable><title>Super Chat - Encrypted</title><link href=IMG_0054.ico rel=icon><link href="https://fonts.googleapis.com/icon?family=Material+Icons"rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Whitney:ital,wght@0,300;0,400;0,500;0,600;0,700;1,300;1,400;1,500;1,600;1,700&display=swap"rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Ginto:ital,wght@0,300;0,400;0,500;0,600;0,700;1,300;1,400;1,500;1,600;1,700&display=swap"rel=stylesheet><style>.unread-separator{display:flex;align-items:center;justify-content:center;margin:15px 0;position:relative}.unread-separator::before{content:"";position:absolute;top:50%;left:0;right:0;height:1px;background:rgba(255,0,0,.2);z-index:1}.unread-label{background:rgba(255,255,255,.9);padding:4px 12px;border-radius:12px;font-size:.7rem;color:#666;z-index:2;border:1px solid rgba(255,0,0,.1);font-weight:700}.message-dropdown{position:absolute;top:-8px;right:8px;background:#fff;border-radius:8px;box-shadow:0 2px 10px rgba(0,0,0,.2);display:none;flex-direction:column;min-width:120px;z-index:100;overflow:hidden}.message-dropdown-item{padding:8px 12px;border:none;background:0 0;text-align:left;cursor:pointer;font-size:.8rem;display:flex;align-items:center;gap:6px;color:#2d3748;transition:background-color .2s ease}.message-dropdown-item:hover{background-color:#f7fafc}.message-dropdown-item.delete{color:#e53e3e}.message-container{position:relative}.message-container:hover .message-dropdown{display:flex}#game-btn{position:fixed;top:15px;right:290px;background-color:#9c27b0;border:none;color:#fff;padding:12px;border-radius:50%;cursor:pointer;font-size:1rem;font-weight:700;box-shadow:0 4px 12px rgba(0,0,0,.3);transition:background-color .2s ease;z-index:1000;min-height:44px;min-width:44px;display:flex;align-items:center;justify-content:center}#game-btn:hover{background-color:#7b1fa2}#game-modal{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.9);display:none;justify-content:center;align-items:center;z-index:1012;padding:20px}#game-container{background:#1a1a1a;border-radius:20px;padding:0;max-width:900px;width:100%;height:80vh;display:flex;flex-direction:column;font-family:Whitney,sans-serif;overflow:hidden}#game-header{background:#2d2d2d;padding:15px 20px;display:flex;justify-content:space-between;align-items:center;border-bottom:2px solid #9c27b0}#game-title{color:#fff;font-size:1.5rem;font-weight:700;font-family:Ginto,Whitney,sans-serif}#game-close{background:0 0;border:none;color:#fff;font-size:1.5rem;cursor:pointer;padding:5px;border-radius:50%;width:40px;height:40px;display:flex;align-items:center;justify-content:center}#game-close:hover{background:rgba(255,255,255,.1)}#game-canvas-container{flex:1;position:relative;overflow:hidden}#game-canvas{width:100%;height:100%;background:#0a0a0a}#game-stats{background:#2d2d2d;padding:10px 20px;display:flex;justify-content:space-between;color:#fff;font-size:.9rem}#steal-brainrot-btn{position:fixed;top:15px;right:235px;background-color:#ff5722;border:none;color:#fff;padding:12px;border-radius:50%;cursor:pointer;font-size:1rem;font-weight:700;box-shadow:0 4px 12px rgba(0,0,0,.3);transition:background-color .2s ease;z-index:1000;min-height:44px;min-width:44px;display:flex;align-items:center;justify-content:center}#steal-brainrot-btn:hover{background-color:#e64a19}#steal-brainrot-modal{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.9);display:none;justify-content:center;align-items:center;z-index:1012;padding:20px}#steal-brainrot-container{background:#1a1a1a;border-radius:20px;padding:0;max-width:900px;width:100%;height:80vh;display:flex;flex-direction:column;font-family:Whitney,sans-serif;overflow:hidden}#steal-brainrot-header{background:#2d2d2d;padding:15px 20px;display:flex;justify-content:space-between;align-items:center;border-bottom:2px solid #ff5722}#steal-brainrot-title{color:#fff;font-size:1.5rem;font-weight:700;font-family:Ginto,Whitney,sans-serif}#steal-brainrot-close{background:0 0;border:none;color:#fff;font-size:1.5rem;cursor:pointer;padding:5px;border-radius:50%;width:40px;height:40px;display:flex;align-items:center;justify-content:center;margin-left:8px}#steal-brainrot-close:hover{background:rgba(255,255,255,.1)}#steal-brainrot-fullscreen{background:0 0;border:none;color:#fff;font-size:1.2rem;cursor:pointer;padding:5px;border-radius:50%;width:40px;height:40px;display:flex;align-items:center;justify-content:center;margin-right:8px}#steal-brainrot-fullscreen:hover{background:rgba(255,255,255,.1)}#steal-brainrot-canvas-container{flex:1;position:relative;overflow:hidden}#steal-brainrot-canvas{width:100%;height:100%;background:#0a0a0a}#steal-brainrot-stats{background:#2d2d2d;padding:10px 20px;display:flex;justify-content:space-between;color:#fff;font-size:.9rem}#steal-brainrot-container.fullscreen{position:fixed;top:0;left:0;width:100vw;height:100vh;max-width:none;max-height:none;border-radius:0;z-index:1014}#steal-brainrot-container.fullscreen #steal-brainrot-canvas-container{height:calc(100vh - 120px)}#game-fullscreen{background:0 0;border:none;color:#fff;font-size:1.2rem;cursor:pointer;padding:5px;border-radius:50%;width:40px;height:40px;display:flex;align-items:center;justify-content:center;margin-right:8px}#game-fullscreen:hover{background:rgba(255,255,255,.1)}#game-container.fullscreen{position:fixed;top:0;left:0;width:100vw;height:100vh;max-width:none;max-height:none;border-radius:0;z-index:1014}#game-container.fullscreen #game-canvas-container{height:calc(100vh - 120px)}#adblocker-btn{position:fixed;top:15px;right:345px;background-color:#4caf50;border:none;color:#fff;padding:12px;border-radius:50%;cursor:pointer;font-size:1rem;font-weight:700;box-shadow:0 4px 12px rgba(0,0,0,.3);transition:background-color .2s ease;z-index:1000;min-height:44px;min-width:44px;display:flex;align-items:center;justify-content:center}#adblocker-btn:hover{background-color:#388e3c}#adblocker-btn.disabled{background-color:#f44336}#adblocker-modal{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.8);display:none;justify-content:center;align-items:center;z-index:1015;padding:20px}#adblocker-container{background:#fff;border-radius:20px;padding:25px;max-width:500px;width:100%;text-align:center;font-family:Whitney,sans-serif}#adblocker-title{margin-bottom:15px;font-family:Ginto,Whitney,sans-serif}.adblocker-status{display:flex;align-items:center;justify-content:center;gap:10px;margin:15px 0;padding:10px;border-radius:8px;font-weight:700}.adblocker-status.active{background-color:#e8f5e9;color:#2e7d32}.adblocker-status.inactive{background-color:#ffebee;color:#c62828}.adblocker-buttons{display:flex;gap:10px;justify-content:center;margin-top:20px}.ad-blocked-iframe{position:relative;width:100%;height:100%}.ad-blocked-iframe::before{content:"Ads blocked";position:absolute;top:5px;right:5px;background:rgba(0,0,0,.7);color:#fff;padding:2px 6px;border-radius:4px;font-size:.7rem;z-index:10}.mention{background-color:rgba(88,101,242,.3);color:#5865f2;padding:1px 4px;border-radius:3px;font-weight:500;cursor:pointer}.mention:hover{background-color:rgba(88,101,242,.5)}.message.mentioned{background-color:rgba(255,255,0,.1)!important;border:1px solid rgba(255,204,0,.3)!important;border-radius:8px}.mention-dropdown{position:absolute;bottom:100%;left:0;right:0;background:#fff;border:1px solid #e2e8f0;border-radius:8px;max-height:150px;overflow-y:auto;z-index:1000;box-shadow:0 4px 12px rgba(0,0,0,.1);display:none}.mention-option{padding:8px 12px;cursor:pointer;border-bottom:1px solid #f7fafc;display:flex;align-items:center;gap:8px}.mention-option:hover{background-color:#f7fafc}.mention-option.active{background-color:#e6f3ff}.mention-avatar{width:20px;height:20px;border-radius:50%;object-fit:cover}.message-actions.own-message{display:none;position:absolute;top:-8px;right:8px;background:#fff;border-radius:15px;box-shadow:0 2px 8px rgba(0,0,0,.15);gap:4px;padding:4px;z-index:10}.message-container.self:hover .message-actions.own-message{display:flex}.message-actions.others-message{display:none;position:absolute;top:-8px;right:8px;background:#fff;border-radius:15px;box-shadow:0 2px 8px rgba(0,0,0,.15);gap:4px;padding:4px;z-index:10}.message-container.other:hover .message-actions.others-message{display:flex}#admin-panel-btn{position:fixed;top:15px;right:180px;background-color:#d35400;border:none;color:#fff;padding:12px;border-radius:50%;cursor:pointer;font-size:1rem;font-weight:700;box-shadow:0 4px 12px rgba(0,0,0,.3);transition:background-color .2s ease;z-index:1000;min-height:44px;min-width:44px;display:flex;align-items:center;justify-content:center}#admin-panel-btn:hover{background-color:#a84300}#admin-modal{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.8);display:none;justify-content:center;align-items:center;z-index:1013;padding:20px}#admin-container{background:#fff;border-radius:20px;padding:25px;max-width:600px;width:100%;max-height:80vh;overflow-y:auto;font-family:Whitney,sans-serif}#admin-title{margin-bottom:20px;font-family:Ginto,Whitney,sans-serif;color:#2d3748;border-bottom:2px solid #e2e8f0;padding-bottom:10px}.admin-section{margin-bottom:25px;padding:15px;background:#f7fafc;border-radius:12px;border:1px solid #e2e8f0}.admin-section h4{margin:0 0 15px 0;color:#4a5568;font-family:Ginto,Whitney,sans-serif}.admin-user-list{max-height:200px;overflow-y:auto;margin-bottom:15px}.admin-user-item{display:flex;justify-content:space-between;align-items:center;padding:10px;border-bottom:1px solid #e2e8f0;transition:background-color .2s ease}.admin-user-item:hover{background-color:#edf2f7}.admin-user-info{display:flex;align-items:center;gap:10px;flex:1}.admin-user-avatar{width:32px;height:32px;border-radius:50%;object-fit:cover}.admin-user-details{display:flex;flex-direction:column;align-items:flex-start}.admin-user-name{font-weight:500;font-size:.9rem;text-align:center;width:100%}.admin-user-rank{font-size:.7rem;font-weight:600;padding:4px 8px;border-radius:12px;margin-top:4px;text-align:center;width:100%;display:flex;justify-content:center;align-items:center}.admin-user-controls{display:flex;gap:8px}.admin-btn{padding:6px 12px;border:none;border-radius:6px;cursor:pointer;font-size:.8rem;font-weight:500;transition:all .2s ease;font-family:Whitney,sans-serif}.admin-btn.delete{background-color:#e53e3e;color:#fff}.admin-btn.delete:hover{background-color:#c53030}.admin-btn.promote{background-color:#38a169;color:#fff}.admin-btn.promote:hover{background-color:#2f855a}.admin-btn.demote{background-color:#d69e2e;color:#fff}.admin-btn.demote:hover{background-color:#b7791f}.admin-rank-controls{display:flex;gap:10px;margin-top:15px}.rank-option{display:flex;flex-direction:column;align-items:center;gap:5px;cursor:pointer;padding:10px;border-radius:8px;border:2px solid transparent;transition:all .2s ease}.rank-option:hover{background-color:#edf2f7}.rank-option.selected{border-color:#4299e1;background-color:#ebf8ff}.rank-color{width:30px;height:30px;border-radius:50%;border:2px solid #fff;box-shadow:0 2px 4px rgba(0,0,0,.1)}.rank-name{font-size:.8rem;font-weight:500;text-align:center}#admin-login{text-align:center;padding:20px}#admin-password-input{width:100%;padding:12px;margin:15px 0;border:2px solid #e2e8f0;border-radius:8px;font-size:1rem;font-family:Whitney,sans-serif}#admin-password-input:focus{border-color:#4299e1;outline:0}.admin-login-btn{padding:10px 20px;background-color:#4299e1;color:#fff;border:none;border-radius:8px;cursor:pointer;font-size:1rem;font-weight:500;transition:background-color .2s ease;font-family:Whitney,sans-serif}.admin-login-btn:hover{background-color:#3182ce}.admin-login-btn.cancel{background-color:#a0aec0}.admin-login-btn.cancel:hover{background-color:#718096}.message-container.self .message-content{justify-content:flex-end}.message-container.other .message-content{justify-content:flex-start}.message-bubble{max-width:100%;display:flex;flex-direction:column}.message{max-width:100%;word-wrap:break-word}#bike-obby-btn{position:fixed;top:15px;right:345px;background-color:#2196f3;border:none;color:#fff;padding:12px;border-radius:50%;cursor:pointer;font-size:1rem;font-weight:700;box-shadow:0 4px 12px rgba(0,0,0,.3);transition:background-color .2s ease;z-index:1000;min-height:44px;min-width:44px;display:flex;align-items:center;justify-content:center}#bike-obby-btn:hover{background-color:#1976d2}#bike-obby-modal{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.9);display:none;justify-content:center;align-items:center;z-index:1012;padding:20px}#bike-obby-container{background:#1a1a1a;border-radius:20px;padding:0;max-width:900px;width:100%;height:80vh;display:flex;flex-direction:column;font-family:Whitney,sans-serif;overflow:hidden}#bike-obby-header{background:#2d2d2d;padding:15px 20px;display:flex;justify-content:space-between;align-items:center;border-bottom:2px solid #2196f3}#bike-obby-title{color:#fff;font-size:1.5rem;font-weight:700;font-family:Ginto,Whitney,sans-serif}#bike-obby-close{background:0 0;border:none;color:#fff;font-size:1.5rem;cursor:pointer;padding:5px;border-radius:50%;width:40px;height:40px;display:flex;align-items:center;justify-content:center}#bike-obby-close:hover{background:rgba(255,255,255,.1)}#bike-obby-fullscreen{background:0 0;border:none;color:#fff;font-size:1.2rem;cursor:pointer;padding:5px;border-radius:50%;width:40px;height:40px;display:flex;align-items:center;justify-content:center;margin-right:8px}#bike-obby-fullscreen:hover{background:rgba(255,255,255,.1)}#bike-obby-canvas-container{flex:1;position:relative;overflow:hidden}#bike-obby-canvas{width:100%;height:100%;background:#0a0a0a}#bike-obby-stats{background:#2d2d2d;padding:10px 20px;display:flex;justify-content:space-between;color:#fff;font-size:.9rem}#bike-obby-container.fullscreen{position:fixed;top:0;left:0;width:100vw;height:100vh;max-width:none;max-height:none;border-radius:0;z-index:1014}#bike-obby-container.fullscreen #bike-obby-canvas-container{height:calc(100vh - 120px)}#minecraft-btn{position:fixed;top:15px;right:400px;background-color:#4caf50;border:none;color:#fff;padding:12px;border-radius:50%;cursor:pointer;font-size:1rem;font-weight:700;box-shadow:0 4px 12px rgba(0,0,0,.3);transition:background-color .2s ease;z-index:1000;min-height:44px;min-width:44px;display:flex;align-items:center;justify-content:center}#minecraft-btn:hover{background-color:#388e3c}#minecraft-modal{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.9);display:none;justify-content:center;align-items:center;z-index:1012;padding:20px}#minecraft-container{background:#1a1a1a;border-radius:20px;padding:0;max-width:900px;width:100%;height:80vh;display:flex;flex-direction:column;font-family:Whitney,sans-serif;overflow:hidden}#minecraft-header{background:#2d2d2d;padding:15px 20px;display:flex;justify-content:space-between;align-items:center;border-bottom:2px solid #4caf50}#minecraft-title{color:#fff;font-size:1.5rem;font-weight:700;font-family:Ginto,Whitney,sans-serif}#minecraft-close{background:0 0;border:none;color:#fff;font-size:1.5rem;cursor:pointer;padding:5px;border-radius:50%;width:40px;height:40px;display:flex;align-items:center;justify-content:center}#minecraft-close:hover{background:rgba(255,255,255,.1)}#minecraft-fullscreen{background:0 0;border:none;color:#fff;font-size:1.2rem;cursor:pointer;padding:5px;border-radius:50%;width:40px;height:40px;display:flex;align-items:center;justify-content:center;margin-right:8px}#minecraft-fullscreen:hover{background:rgba(255,255,255,.1)}#minecraft-canvas-container{flex:1;position:relative;overflow:hidden}#minecraft-canvas{width:100%;height:100%;background:#0a0a0a}#minecraft-stats{background:#2d2d2d;padding:10px 20px;display:flex;justify-content:space-between;color:#fff;font-size:.9rem}#minecraft-container.fullscreen{position:fixed;top:0;left:0;width:100vw;height:100vh;max-width:none;max-height:none;border-radius:0;z-index:1014}#minecraft-container.fullscreen #minecraft-canvas-container{height:calc(100vh - 120px)}#insert-link-btn{position:fixed;top:15px;right:455px;background-color:#ff9800;border:none;color:#fff;padding:12px;border-radius:50%;cursor:pointer;font-size:1rem;font-weight:700;box-shadow:0 4px 12px rgba(0,0,0,.3);transition:background-color .2s ease;z-index:1000;min-height:44px;min-width:44px;display:flex;align-items:center;justify-content:center}#insert-link-btn:hover{background-color:#f57c00}@media (max-width:1200px){.app-container{width:98%;height:95%}}@media (max-width:768px){.app-container{width:100%;height:100%;max-width:none;max-height:none;border-radius:0}.sidebar{width:70px;transition:width .3s ease}.dm-section{display:none}.sidebar:hover{width:240px}.sidebar:hover .dm-section{display:flex}#adblocker-btn,#admin-panel-btn,#audio-call-btn,#bike-obby-btn,#clear-messages-btn,#edit-wallpaper,#game-btn,#insert-link-btn,#link-share-btn,#minecraft-btn,#profile-picture-btn,#steal-brainrot-btn{transform:scale(.8)}#edit-wallpaper{right:10px}#audio-call-btn{right:55px}#clear-messages-btn{right:100px}#profile-picture-btn{right:145px}#link-share-btn{right:190px}#adblocker-btn{right:235px}#game-btn{right:280px}#steal-brainrot-btn{right:325px}#admin-panel-btn{right:370px}#bike-obby-btn{right:415px}#minecraft-btn{right:460px}#insert-link-btn{right:505px}.message-container{max-width:95%}}@media (max-width:480px){.header{font-size:1.1rem;padding:15px 10px}.header span{font-size:.65rem}.message{padding:10px 14px;font-size:.9rem}.input-container{padding:8px 10px}input{font-size:14px;padding:10px 14px}#adblocker-btn,#admin-panel-btn,#audio-call-btn,#bike-obby-btn,#clear-messages-btn,#edit-wallpaper,#game-btn,#insert-link-btn,#link-share-btn,#minecraft-btn,#profile-picture-btn,#steal-brainrot-btn{position:fixed;right:10px;transform:scale(.7)}#edit-wallpaper{top:15px}#audio-call-btn{top:65px}#clear-messages-btn{top:115px}#profile-picture-btn{top:165px}#link-share-btn{top:215px}#adblocker-btn{top:265px}#game-btn{top:315px}#steal-brainrot-btn{top:365px}#admin-panel-btn{top:415px}#bike-obby-btn{top:465px}#minecraft-btn{top:515px}#insert-link-btn{top:565px}}*{-webkit-tap-highlight-color:transparent;box-sizing:border-box}body{margin:0;font-family:Whitney,-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;background:linear-gradient(135deg,#667eea,#764ba2);height:100vh;height:100dvh;display:flex;justify-content:center;align-items:center;background-size:cover;background-position:center;background-attachment:fixed;padding:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);overflow:hidden}.app-container{display:flex;width:95%;max-width:1200px;height:90%;max-height:800px;background:rgba(255,255,255,.95);border-radius:20px;box-shadow:0 20px 60px rgba(0,0,0,.3);overflow:hidden}.sidebar{width:240px;background-color:#2f3136;display:flex;flex-direction:column;overflow:hidden}.server-list{display:flex;flex-direction:column;align-items:center;padding:12px 0;background-color:#202225;border-bottom:1px solid rgba(255,255,255,.1)}.server-icon{width:48px;height:48px;border-radius:50%;background-color:#36393f;margin:8px 0;display:flex;align-items:center;justify-content:center;color:#dcddde;font-size:18px;cursor:pointer;transition:border-radius .2s ease,background-color .2s ease}.server-icon:hover{border-radius:16px;background-color:#5865f2}.server-icon.active{border-radius:16px;background-color:#5865f2}.dm-section{flex:1;display:flex;flex-direction:column;overflow:hidden}.dm-header{padding:16px 8px 8px 16px;color:#8e9297;font-size:12px;font-weight:600;text-transform:uppercase;display:flex;justify-content:space-between;align-items:center;font-family:Ginto,Whitney,sans-serif}.dm-header span{cursor:pointer;transition:color .2s ease}.dm-header span:hover{color:#dcddde}.dm-list{flex:1;overflow-y:auto;padding:0 8px}.dm-item{display:flex;align-items:center;padding:8px;margin:2px 0;border-radius:4px;cursor:pointer;color:#8e9297;transition:background-color .2s ease,color .2s ease;font-family:Whitney,sans-serif}.dm-item:hover{background-color:rgba(79,84,92,.32);color:#dcddde}.dm-item.active{background-color:rgba(79,84,92,.6);color:#fff}.dm-avatar{width:32px;height:32px;border-radius:50%;margin-right:12px;background-color:#36393f;display:flex;align-items:center;justify-content:center;font-size:14px;overflow:hidden}.dm-avatar img{width:100%;height:100%;border-radius:50%;object-fit:cover}.dm-info{flex:1;display:flex;flex-direction:column}.dm-name{font-size:14px;font-weight:500;font-family:Whitney,sans-serif}.dm-status{font-size:10px;color:#72767d;font-family:Whitney,sans-serif}.dm-status.online{color:#3ba55c}.dm-status.offline{color:#72767d}.user-section{padding:8px;background-color:#292b2f;display:flex;align-items:center}.user-avatar{width:32px;height:32px;border-radius:50%;margin-right:8px;background-color:#36393f;display:flex;align-items:center;justify-content:center;font-size:14px;overflow:hidden}.user-avatar img{width:100%;height:100%;border-radius:50%;object-fit:cover}.user-info{flex:1;display:flex;flex-direction:column}.user-name{font-size:14px;font-weight:600;color:#fff;font-family:Whitney,sans-serif;cursor:pointer;position:relative;display:flex;align-items:center;gap:5px}.user-name:hover{color:#dcddde}.user-name::after{content:"edit";font-family:'Material Icons';font-size:14px;opacity:0;transition:opacity .2s ease}.user-name:hover::after{opacity:1}.user-tag{font-size:12px;color:#b9bbbe;font-family:Whitney,sans-serif}.user-controls{display:flex;gap:4px}.user-control{width:32px;height:32px;border-radius:4px;display:flex;align-items:center;justify-content:center;color:#b9bbbe;cursor:pointer;transition:background-color .2s ease,color .2s ease}.user-control:hover{background-color:rgba(79,84,92,.32);color:#dcddde}.chat-container{flex:1;display:flex;flex-direction:column;overflow:hidden}.header{background-color:#5a67d8;color:#fff;font-size:1.4rem;font-weight:700;padding:20px 15px;text-align:center;display:flex;justify-content:space-between;align-items:center;padding-top:max(20px,env(safe-area-inset-top));font-family:Ginto,Whitney,sans-serif}.header span{font-size:.75rem;opacity:.9;cursor:default;display:flex;align-items:center;gap:5px;font-family:Whitney,sans-serif}#messages{flex:1;padding:15px;overflow-y:auto;background:0 0;display:flex;flex-direction:column;gap:12px}.message-container{max-width:85%;display:flex;flex-direction:column;animation:fadeIn .3s ease forwards;position:relative}.message-container.self{align-self:flex-end;align-items:flex-end}.message-container.other{align-self:flex-start;align-items:flex-start}.message-content{display:flex;align-items:flex-end;gap:8px;max-width:100%}.message-avatar{width:32px;height:32px;border-radius:50%;object-fit:cover;flex-shrink:0}.message-bubble{display:flex;flex-direction:column;max-width:calc(100% - 40px)}.sender-name{font-size:.7rem;color:#666;margin-bottom:3px;padding:0 8px;font-family:Whitney,sans-serif;font-weight:500}.message{padding:12px 16px;border-radius:20px;word-wrap:break-word;font-size:.95rem;line-height:1.3;position:relative;max-width:fit-content;min-width:0;white-space:pre-wrap;word-break:break-word;font-family:Whitney,sans-serif}.message.self{background-color:#6b7de8;color:#fff;border-bottom-right-radius:6px}.message.other{background-color:#e2e8f0;color:#2d3748;border-bottom-left-radius:6px}.message a{color:#5865f2;text-decoration:none;font-weight:500}.message.self a{color:#fff;text-decoration:underline}.message.other a{color:#5865f2}.message a:hover{text-decoration:underline}.message strong{font-weight:600}.message em{font-style:italic}.date-separator{display:flex;align-items:center;justify-content:center;margin:15px 0;position:relative}.date-separator::before{content:"";position:absolute;top:50%;left:0;right:0;height:1px;background:rgba(255,0,0,.2);z-index:1}.date-label{background:rgba(255,255,255,.8);padding:4px 12px;border-radius:12px;font-size:.7rem;color:#666;z-index:2;border:1px solid rgba(255,0,0,.1);font-family:Whitney,sans-serif}.encryption-indicator{font-size:.6rem;color:#38a169;margin-top:2px;padding:0 8px;text-align:right;font-family:Whitney,sans-serif}.encryption-indicator.other{text-align:left}.message-actions{position:absolute;top:-8px;right:8px;background:#fff;border-radius:15px;box-shadow:0 2px 8px rgba(0,0,0,.15);display:none;gap:4px;padding:4px;z-index:10}.message-container:hover .message-actions{display:flex}.message-action{background:0 0;border:none;border-radius:50%;width:28px;height:28px;display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:.8rem;transition:background-color .2s ease}.message-action:hover{background:#f7fafc}.delete-btn{color:#e53e3e}.edit-btn{color:#3182ce}.reaction-btn{color:#718096}.attachment-btn{color:#805ad5}@keyframes fadeIn{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}.input-container{display:flex;flex-direction:column;border-top:1px solid #e2e8f0;background:#fff;padding:10px 15px;padding-bottom:max(10px,env(safe-area-inset-bottom));position:relative}form{display:flex;gap:10px}input{flex:1;font-size:16px;padding:12px 16px;border:2px solid #e2e8f0;border-radius:25px;outline:0;background:#fff;min-height:44px;font-family:Whitney,sans-serif}input:focus{border-color:#5a67d8}button{background-color:#5a67d8;border:none;color:#fff;padding:0 20px;border-radius:25px;cursor:pointer;font-weight:700;min-height:44px;min-width:60px;font-family:Whitney,sans-serif}button:disabled{background-color:#a0aec0;cursor:not-allowed}#edit-wallpaper{position:fixed;top:15px;right:15px;background-color:#5a67d8;border:none;color:#fff;padding:12px;border-radius:50%;cursor:pointer;font-size:1rem;font-weight:700;box-shadow:0 4px 12px rgba(0,0,0,.3);transition:background-color .2s ease;z-index:1000;min-height:44px;min-width:44px;display:flex;align-items:center;justify-content:center}#edit-wallpaper:hover{background-color:#434190}#audio-call-btn{position:fixed;top:15px;right:70px;background-color:#38a169;border:none;color:#fff;padding:12px;border-radius:50%;cursor:pointer;font-size:1rem;font-weight:700;box-shadow:0 4px 12px rgba(0,0,0,.3);transition:background-color .2s ease;z-index:1000;min-height:44px;min-width:44px;display:flex;align-items:center;justify-content:center}#audio-call-btn:hover{background-color:#2f855a}#clear-messages-btn{position:fixed;top:15px;right:125px;background-color:#e53e3e;border:none;color:#fff;padding:12px;border-radius:50%;cursor:pointer;font-size:1rem;font-weight:700;box-shadow:0 4px 12px rgba(0,0,0,.3);transition:background-color .2s ease;z-index:1000;min-height:44px;min-width:44px;display:flex;align-items:center;justify-content:center}#clear-messages-btn:hover{background-color:#c53030}#profile-picture-btn{position:fixed;top:15px;right:180px;background-color:#9f7aea;border:none;color:#fff;padding:12px;border-radius:50%;cursor:pointer;font-size:1rem;font-weight:700;box-shadow:0 4px 12px rgba(0,0,0,.3);transition:background-color .2s ease;z-index:1000;min-height:44px;min-width:44px;display:flex;align-items:center;justify-content:center}#profile-picture-btn:hover{background-color:#805ad5}#link-share-btn{position:fixed;top:15px;right:235px;background-color:#ed8936;border:none;color:#fff;padding:12px;border-radius:50%;cursor:pointer;font-size:1rem;font-weight:700;box-shadow:0 4px 12px rgba(0,0,0,.3);transition:background-color .2s ease;z-index:1000;min-height:44px;min-width:44px;display:flex;align-items:center;justify-content:center}#link-share-btn:hover{background-color:#dd6b20}#encryption-key-modal{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.8);display:none;justify-content:center;align-items:center;z-index:1001;padding:20px}#encryption-key-container{background:#fff;border-radius:20px;padding:25px;max-width:400px;width:100%;text-align:center;font-family:Whitney,sans-serif}#encryption-key-display{background:#f7fafc;border:2px dashed #e2e8f0;border-radius:12px;padding:15px;margin:15px 0;font-family:monospace;word-break:break-all;font-size:.9rem;line-height:1.4}.encryption-key-buttons{display:flex;gap:10px;justify-content:center;margin-top:20px;flex-wrap:wrap}.encryption-key-buttons button{min-width:120px}#enter-key-modal{position:fixed;top:0;left:0;width:100%;display:none;justify-content:center;align-items:center;z-index:1002;padding:20px}#enter-key-container{background:#fff;border-radius:20px;padding:25px;font-family:Whitney,sans-serif}#encryption-key-input{margin:15px 0}.key-entry-buttons{display:flex;gap:10px;justify-content:center;margin-top:20px;flex-wrap:wrap}.key-entry-buttons button{min-width:120px}#wallpaper-modal{position:fixed;top:0;left:0;display:none;justify-content:center;align-items:center;z-index:999;padding:20px}#wallpaper-options{background:#fff;border-radius:20px;padding:25px;display:flex;gap:15px;flex-wrap:wrap;justify-content:center;overflow-y:auto}.wallpaper-option{width:100px;height:80px;border-radius:12px;cursor:pointer;border:3px solid transparent;background-size:cover;background-position:center;transition:transform .2s ease}.wallpaper-option:hover{transform:scale(1.05);border-color:#5a67d8}.wallpaper-label{font-size:.7rem;text-align:center;margin-top:5px;color:#666;font-family:Whitney,sans-serif}#profile-picture-modal{position:fixed;top:0;left:0;display:none;justify-content:center;align-items:center;z-index:1005;padding:20px}#profile-picture-options{background:#fff;border-radius:20px;padding:25px;display:flex;gap:15px;flex-wrap:wrap;justify-content:center;overflow-y:auto}.profile-picture-option{width:80px;height:80px;border-radius:50%;cursor:pointer;border:3px solid transparent;background-size:cover;background-position:center;transition:transform .2s ease}.profile-picture-option:hover{transform:scale(1.1);border-color:#5a67d8}.profile-picture-label{font-size:.7rem;text-align:center;margin-top:5px;color:#666;font-family:Whitney,sans-serif}.status{text-align:center;padding:8px;font-size:.75rem;background:#f7fafc;border-top:1px solid #e2e8f0;min-height:32px;display:flex;align-items:center;justify-content:center;font-family:Whitney,sans-serif}.status.connected{color:#38a169}.status.disconnected{color:#e53e3e}.error-message{background:#fed7d7;border:1px solid #feb2b2;border-radius:12px;padding:12px;margin:12px;font-size:.75rem;color:#c53030;text-align:center;display:none;font-family:Whitney,sans-serif}.success-message{background:#c6f6d5;border:1px solid #9ae6b4;border-radius:12px;padding:12px;margin:12px;font-size:.75rem;color:#276749;text-align:center;font-family:Whitney,sans-serif}.loading-dots:after{content:'';animation:dots 1.5s steps(5,end) infinite}@keyframes dots{0%,20%{content:'.'}40%{content:'..'}60%{content:'...'}100%,80%{content:''}}.wallpaper-grid{display:flex;flex-direction:column;align-items:center;gap:8px}.profile-picture-grid{display:flex;flex-direction:column;align-items:center;gap:8px}.security-indicator{position:fixed;top:15px;left:15px;background:#38a169;color:#fff;padding:8px 12px;border-radius:20px;font-size:.7rem;font-weight:700;box-shadow:0 2px 8px rgba(0,0,0,.2);z-index:1000;display:flex;align-items:center;gap:6px;cursor:pointer;font-family:Whitney,sans-serif}.security-indicator:hover{background:#2f855a}#audio-call-container{position:fixed;top:0;left:0;display:none;flex-direction:column;justify-content:center;align-items:center;z-index:1003;padding:20px}#audio-call-info{text-align:center;color:#fff;margin-bottom:30px;font-family:Whitney,sans-serif}#caller-avatar{width:120px;height:120px;border-radius:50%;object-fit:cover;margin-bottom:20px;border:4px solid #fff}#caller-name{font-size:1.5rem;font-weight:700;margin-bottom:10px;font-family:Ginto,Whitney,sans-serif}#call-status{font-size:1rem;color:#ccc;font-family:Whitney,sans-serif}#call-controls{display:flex;gap:20px;margin-top:30px}.call-btn{background-color:#e53e3e;border:none;color:#fff;padding:15px;border-radius:50%;cursor:pointer;font-size:1.5rem;width:70px;height:70px;display:flex;align-items:center;justify-content:center;box-shadow:0 4px 12px rgba(0,0,0,.3);transition:background-color .2s ease}.call-btn:hover{background-color:#c53030}.call-btn.accept{background-color:#38a169}.call-btn.accept:hover{background-color:#2f855a}#incoming-call-modal{position:fixed;top:0;left:0;display:none;justify-content:center;align-items:center;z-index:1004;padding:20px}#incoming-call-container{background:#fff;border-radius:20px;padding:25px;font-family:Whitney,sans-serif}#incoming-call-info{font-size:1.2rem;margin-bottom:20px;font-family:Whitney,sans-serif}#incoming-call-controls{display:flex;gap:15px;justify-content:center}.typing-indicator{display:flex;align-items:center;gap:4px;font-size:.7rem;color:#666;margin:5px 0;padding:0 8px;background:0 0;align-self:flex-start;justify-content:flex-start;font-family:Whitney,sans-serif}.typing-dots{display:flex;gap:3px}.typing-dot{width:6px;height:6px;border-radius:50%;background-color:#a0aec0;animation:typing-wave 1.4s ease-in-out infinite both}.typing-dot:nth-child(1){animation-delay:-.32s}.typing-dot:nth-child(2){animation-delay:-.16s}@keyframes typing-wave{0%,100%,80%{transform:scale(.8);opacity:.5}40%{transform:scale(1);opacity:1}}#call-user-modal{position:fixed;top:0;left:0;display:none;justify-content:center;align-items:center;z-index:1006;padding:20px}#call-user-container{background:#fff;border-radius:20px;padding:25px;font-family:Whitney,sans-serif}#call-user-list{max-height:300px;overflow-y:auto;margin:15px 0}.call-user-option{display:flex;align-items:center;gap:10px;padding:12px;border-radius:10px;cursor:pointer;transition:background-color .2s ease;font-family:Whitney,sans-serif}.call-user-option:hover{background-color:#f7fafc}.call-user-avatar{width:40px;height:40px;border-radius:50%;object-fit:cover}.call-user-name{font-weight:500;font-family:Whitney,sans-serif}.call-user-status{font-size:.7rem;color:#38a169;font-family:Whitney,sans-serif}.call-user-status.offline{color:#a0aec0}.call-user-buttons{display:flex;gap:10px;justify-content:center;margin-top:20px}#microphone-permission-modal{position:fixed;top:0;left:0;display:none;justify-content:center;align-items:center;z-index:1007;padding:20px}#microphone-permission-container{background:#fff;border-radius:20px;padding:25px;font-family:Whitney,sans-serif}#microphone-permission-info{font-size:1.1rem;margin-bottom:20px;font-family:Whitney,sans-serif}#microphone-permission-controls{display:flex;gap:15px;justify-content:center}.hidden{display:none!important}.material-icons{font-size:inherit;vertical-align:middle}.notification{position:fixed;top:20px;right:20px;background:#fff;border-radius:10px;padding:15px 20px;box-shadow:0 4px 12px rgba(0,0,0,.3);z-index:2000;display:flex;align-items:center;gap:10px;max-width:350px;animation:slideIn .3s ease;font-family:Whitney,sans-serif}.notification.call{border-left:4px solid #38a169}.notification-content{flex:1}.notification-title{font-weight:700;margin-bottom:5px;font-family:Ginto,Whitney,sans-serif}.notification-message{font-size:.9rem;color:#666;font-family:Whitney,sans-serif}.notification-actions{display:flex;gap:8px;margin-top:8px}.notification-btn{padding:6px 12px;border-radius:6px;border:none;cursor:pointer;font-size:.8rem;font-weight:700;font-family:Whitney,sans-serif}.notification-btn.accept{background-color:#38a169;color:#fff}.notification-btn.decline{background-color:#e53e3e;color:#fff}.notification-btn.close{background-color:#a0aec0;color:#fff}@keyframes slideIn{from{transform:translateX(100%);opacity:0}to{transform:translateX(0);opacity:1}}@keyframes slideOut{from{transform:translateX(0);opacity:1}to{transform:translateX(100%);opacity:0}}.reactions-container{display:flex;flex-wrap:wrap;gap:4px;margin-top:6px;padding:0 8px}.reaction{display:flex;align-items:center;gap:4px;background:rgba(0,0,0,.05);border-radius:12px;padding:2px 6px;font-size:.75rem;cursor:pointer;transition:background-color .2s ease;font-family:Whitney,sans-serif}.reaction:hover{background:rgba(0,0,0,.1)}.reaction.self-reacted{background:rgba(88,101,242,.2);border:1px solid rgba(88,101,242,.5)}.reaction-count{font-size:.7rem;color:#666;font-family:Whitney,sans-serif}#emoji-picker-modal{position:fixed;top:0;left:0;display:none;justify-content:center;align-items:center;z-index:1008;padding:20px}#emoji-picker-container{background:#fff;border-radius:20px;padding:25px;font-family:Whitney,sans-serif}#emoji-picker-title{margin-bottom:15px;font-weight:700;font-family:Ginto,Whitney,sans-serif}#emoji-picker-grid{display:grid;grid-template-columns:repeat(6,1fr);gap:8px;margin:15px 0}.emoji-option{font-size:1.5rem;padding:8px;border-radius:8px;cursor:pointer;transition:background-color .2s ease}.emoji-option:hover{background-color:#f7fafc}.emoji-picker-buttons{display:flex;gap:10px;justify-content:center;margin-top:20px}#file-upload-modal{position:fixed;top:0;left:0;display:none;justify-content:center;align-items:center;z-index:1009;padding:20px}#file-upload-container{background:#fff;border-radius:20px;padding:25px;font-family:Whitney,sans-serif}#file-upload-area{border:2px dashed #e2e8f0;border-radius:12px;padding:30px;margin:15px 0;cursor:pointer;transition:border-color .2s ease}#file-upload-area:hover{border-color:#5a67d8}#file-upload-area.dragover{border-color:#5a67d8;background-color:#f7fafc}#file-upload-icon{font-size:3rem;color:#a0aec0;margin-bottom:15px}#file-upload-text{font-size:1rem;color:#4a5568;margin-bottom:10px;font-family:Whitney,sans-serif}#file-upload-hint{font-size:.8rem;color:#718096;font-family:Whitney,sans-serif}#file-preview{margin:15px 0;max-height:200px;overflow:hidden;border-radius:8px}#file-preview img,#file-preview video{max-width:100%;max-height:200px;border-radius:8px}.file-upload-buttons{display:flex;gap:10px;justify-content:center;margin-top:20px}#gif-sticker-modal{position:fixed;top:0;left:0;display:none;justify-content:center;align-items:center;z-index:1010;padding:20px}#gif-sticker-container{background:#fff;border-radius:20px;padding:25px;overflow:hidden;display:flex;flex-direction:column;font-family:Whitney,sans-serif}#gif-sticker-tabs{display:flex;gap:0;border-bottom:1px solid #e2e8f0;margin-bottom:15px}.gif-sticker-tab{flex:1;padding:12px;background:0 0;border:none;border-bottom:3px solid transparent;cursor:pointer;font-weight:500;transition:all .2s ease;font-family:Whitney,sans-serif}.gif-sticker-tab.active{border-bottom-color:#5a67d8;color:#5a67d8}#gif-sticker-content{flex:1;overflow-y:auto;padding:10px 0}.gif-sticker-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:10px}.gif-sticker-item{width:100%;aspect-ratio:1;border-radius:8px;overflow:hidden;cursor:pointer;transition:transform .2s ease}.gif-sticker-item:hover{transform:scale(1.05)}.gif-sticker-item img{width:100%;height:100%;object-fit:cover}.gif-sticker-buttons{display:flex;gap:10px;justify-content:center;margin-top:20px}.attachment{margin-top:8px;border-radius:8px;overflow:hidden;max-width:300px}.attachment img,.attachment video{max-width:100%;max-height:200px;border-radius:8px}.attachment-file{display:flex;align-items:center;gap:8px;padding:8px 12px;background:rgba(0,0,0,.05);border-radius:8px}.file-icon{font-size:1.5rem;color:#4a5568}.file-info{flex:1}.file-name{font-weight:500;font-size:.9rem;font-family:Whitney,sans-serif}.file-size{font-size:.7rem;color:#718096;font-family:Whitney,sans-serif}.download-btn{background:0 0;border:none;color:#5a67d8;cursor:pointer;padding:4px;border-radius:4px}.download-btn:hover{background:rgba(90,103,216,.1)}.input-controls{display:flex;gap:8px;margin-bottom:8px}.input-control-btn{background:0 0;border:none;padding:8px;border-radius:50%;cursor:pointer;color:#718096;transition:background-color .2s ease,color .2s ease}.input-control-btn:hover{background:#f7fafc;color:#4a5568}.input-control-btn.active{background:#5a67d8;color:#fff}.gif-loading{display:flex;align-items:center;justify-content:center;height:100px;color:#666;font-family:Whitney,sans-serif}.gif-search{margin-bottom:15px}.gif-search input{width:100%;padding:10px;border:1px solid #e2e8f0;border-radius:8px;font-size:14px;font-family:Whitney,sans-serif}.sticker-category{margin-bottom:15px}.sticker-category h4{margin:0 0 8px 0;color:#4a5568;font-size:.9rem;font-family:Ginto,Whitney,sans-serif}#link-share-modal{position:fixed;top:0;left:0;display:none;justify-content:center;align-items:center;z-index:1011;padding:20px}#link-share-container{background:#fff;border-radius:20px;padding:25px;font-family:Whitney,sans-serif}#link-share-title{margin-bottom:15px;font-family:Ginto,Whitney,sans-serif}.link-share-field{margin:15px 0;text-align:left}.link-share-field label{display:block;margin-bottom:5px;font-weight:500;color:#4a5568}.link-share-field input{border:1px solid #e2e8f0;border-radius:8px;font-family:Whitney,sans-serif}.link-share-buttons{display:flex;gap:10px;justify-content:center;margin-top:20px}.link-preview{margin-top:10px;padding:10px;background:#f7fafc;border-radius:8px;border:1px solid #e2e8f0;text-align:left}.link-preview-title{font-weight:500;margin-bottom:5px;font-family:Whitney,sans-serif}.link-preview-url{font-size:.8rem;color:#718096;font-family:Whitney,sans-serif}.formatting-controls{display:flex;gap:4px;margin-bottom:8px}.format-btn{background:0 0;border:none;padding:6px 8px;border-radius:4px;cursor:pointer;color:#718096;font-size:14px;font-weight:700;transition:background-color .2s ease,color .2s ease;font-family:Whitney,sans-serif}.format-btn:hover{background:#f7fafc;color:#4a5568}.format-btn.active{background:#5a67d8;color:#fff}.message.mentioned{background-color:rgba(255,255,0,.2)!important;border:1px solid rgba(255,204,0,.5)!important;border-radius:8px}.mention{background-color:rgba(88,101,242,.3);color:#5865f2;padding:1px 4px;border-radius:3px;font-weight:500}.edited-indicator{font-size:.7rem;color:#72767d;font-style:italic;margin-left:4px}.sw-notification{position:fixed;bottom:20px;left:20px;background:#4a5568;color:#fff;padding:12px 16px;border-radius:8px;z-index:10000;display:none}.reload-protection-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.95);display:none;justify-content:center;align-items:center;z-index:99999;flex-direction:column;color:#fff;text-align:center;font-family:Whitney,sans-serif}.reload-protection-content{background:#1a1a1a;padding:30px;border-radius:20px;max-width:500px;width:90%;border:3px solid #e53e3e;box-shadow:0 10px 30px rgba(0,0,0,.5)}.reload-protection-title{font-size:1.5rem;margin-bottom:15px;color:#e53e3e;font-family:Ginto,Whitney,sans-serif;display:flex;align-items:center;justify-content:center;gap:10px}.reload-protection-message{margin-bottom:20px;line-height:1.5;font-size:1rem}.reload-protection-buttons{display:flex;gap:15px;justify-content:center}.reload-protection-btn{padding:12px 24px;border:none;border-radius:8px;cursor:pointer;font-weight:600;transition:all .2s ease;font-size:1rem;min-width:140px}.reload-protection-btn.continue{background-color:#e53e3e;color:#fff}.reload-protection-btn.continue:hover{background-color:#c53030;transform:translateY(-2px)}.reload-protection-btn.cancel{background-color:#38a169;color:#fff}.reload-protection-btn.cancel:hover{background-color:#2f855a;transform:translateY(-2px)}</style><div id=reload-protection-overlay class=reload-protection-overlay><div class=reload-protection-content><div class=reload-protection-title><span class=material-icons>warning</span> STOP! Page Reload Protection</div><div class=reload-protection-message><p><strong>Are you sure you want to reload the page?</strong><p>This will interrupt your chat, games, and may cause data loss!<p>All unsent messages and game progress will be lost.</div><div class=reload-protection-buttons><button id=cancel-reload-btn class="cancel reload-protection-btn">Stay on Page</button> <button id=continue-reload-btn class="reload-protection-btn continue">Reload Anyway</button></div></div></div><div id=security-indicator class=security-indicator title="Click to manage encryption key"><span class=material-icons>lock</span> Encrypted</div><button id=edit-wallpaper title="Edit wallpaper"><span class=material-icons>palette</span></button> <button id=audio-call-btn title="Start audio call"><span class=material-icons>call</span></button> <button id=clear-messages-btn title="Clear all messages"><span class=material-icons>delete</span></button> <button id=profile-picture-btn title="Change profile picture"><span class=material-icons>person</span></button> <button id=link-share-btn title="Share a link"><span class=material-icons>link</span></button> <button id=insert-link-btn title="Insert Link"><span class=material-icons>insert_link</span></button> <button id=game-btn title="Play Grow a Garden"><span class=material-icons>sports_esports</span></button> <button id=steal-brainrot-btn title="Play Steal a Brainrot"><span class=material-icons>casino</span></button> <button id=bike-obby-btn title="Play Bike Obby"><span class=material-icons>directions_bike</span></button> <button id=minecraft-btn title="Play Minecraft"><span class=material-icons>diamond</span></button> <button id=admin-panel-btn title="Admin Panel"><span class=material-icons>admin_panel_settings</span></button> <button id=adblocker-btn title="Toggle Adblocker"><span class=material-icons>block</span></button><div class=app-container><div class=sidebar><div class=server-list><div class="active server-icon"data-server=home><span class=material-icons>home</span></div><div class=server-icon data-server=dms><span class=material-icons>chat</span></div></div><div class=dm-section><div class=dm-header>DIRECT MESSAGES <span class=material-icons>add</span></div><div id=dm-list class=dm-list></div><div class=user-section><div id=user-sidebar-avatar class=user-avatar><span class=material-icons>person</span></div><div class=user-info><div id=user-sidebar-name class=user-name>Loading...</div><div id=user-sidebar-tag class=user-tag>#0000</div></div><div class=user-controls><div class=user-control><span class=material-icons>mic</span></div><div class=user-control><span class=material-icons>headphones</span></div><div class=user-control><span class=material-icons>settings</span></div></div></div></div></div><div id=chat-container class=chat-container aria-label="Encrypted chat application"role=main><div class=header><div>Super Chat ðŸ”’</div><span id=user-display>You: ...</span></div><div id=error-message class="hidden error-message"></div><div id=success-message class="hidden success-message"></div><div id=messages aria-live=polite aria-relevant=additions><div id=loading>Loading messages<span class=loading-dots></span></div></div><div class=input-container><div class=input-controls><button id=file-upload-btn title="Upload file"class=input-control-btn><span class=material-icons>attach_file</span></button> <button id=gif-sticker-btn title="GIFs & Stickers"class=input-control-btn><span class=material-icons>gif</span></button> <button id=bold-btn title="Bold (Cmd+B)"class=format-btn><strong>B</strong></button> <button id=italic-btn title="Italic (Cmd+I)"class=format-btn><em>I</em></button></div><div id=typing-indicator class="hidden typing-indicator"><span id=typing-text></span><div class=typing-dots><div class=typing-dot></div><div class=typing-dot></div><div class=typing-dot></div></div></div><form aria-label="Send encrypted message form"id=chat-form><input id=message-input placeholder="Type your encrypted message..."aria-required=true autocomplete=off required> <button id=send-button type=submit>Send</button></form></div><div id=status class="hidden status"></div></div></div><div id=adblocker-modal><div id=adblocker-container><h3 id=adblocker-title><span class=material-icons>block</span> Adblocker Settings</h3><p>Toggle ad blocking for games on or off:<div id=adblocker-status class="active adblocker-status"><span class=material-icons>check_circle</span> <span>Adblocker is currently ACTIVE</span></div><div class=adblocker-buttons><button id=disable-adblocker-btn style=background-color:#f44336>Disable Adblocker</button> <button id=enable-adblocker-btn style=background-color:#4caf50>Enable Adblocker</button> <button id=close-adblocker-btn>Close</button></div></div></div><div id=admin-modal><div id=admin-container><h3 id=admin-title><span class=material-icons>admin_panel_settings</span> Admin Panel</h3><div id=admin-login class=admin-section><h4>Admin Authentication Required</h4><p>Please enter the admin password to access the admin panel:</p><input id=admin-password-input placeholder="Enter admin password"type=password><div style=display:flex;gap:10px;justify-content:center;margin-top:15px><button id=admin-login-btn class=admin-login-btn>Login</button> <button id=admin-cancel-btn class="admin-login-btn cancel">Cancel</button></div></div><div id=admin-content class=hidden><div class=admin-section><h4>User Management</h4><div id=admin-user-list class=admin-user-list></div></div><div class=admin-section><h4>Rank Management</h4><p>Select a rank to assign to users:<div id=admin-rank-controls class=admin-rank-controls></div></div><div style=text-align:center;margin-top:20px><button id=admin-close-btn class=admin-login-btn>Close Admin Panel</button></div></div></div></div><div id=game-modal><div id=game-container><div id=game-header><div id=game-title>Grow a Garden</div><div class=header-controls><button id=game-fullscreen title="Toggle Fullscreen"><span class=material-icons>fullscreen</span></button> <button id=game-close><span class=material-icons>close</span></button></div></div><div id=game-canvas-container><div class=ad-blocked-iframe><iframe id=game-frame src=https://maddox05.github.io/basic-ruffle-player/html/grow_a_garden/index.html style=width:100%;height:100%;border:none></iframe></div></div><div id=game-stats><div id=game-score>Playing: Grow a Garden</div></div></div></div><div id=steal-brainrot-modal><div id=steal-brainrot-container><div id=steal-brainrot-header><div id=steal-brainrot-title>Steal a Brainrot</div><div class=header-controls><button id=steal-brainrot-fullscreen title="Toggle Fullscreen"><span class=material-icons>fullscreen</span></button> <button id=steal-brainrot-close><span class=material-icons>close</span></button></div></div><div id=steal-brainrot-canvas-container><div class=ad-blocked-iframe><iframe id=steal-brainrot-frame src=https://maddox05.github.io/basic-ruffle-player/html/steal_a_brainrot_2/index.html style=width:100%;height:100%;border:none></iframe></div></div><div id=steal-brainrot-stats><div id=steal-brainrot-score>Playing: Steal a Brainrot</div></div></div></div><div id=bike-obby-modal><div id=bike-obby-container><div id=bike-obby-header><div id=bike-obby-title>Bike Obby</div><div class=header-controls><button id=bike-obby-fullscreen title="Toggle Fullscreen"><span class=material-icons>fullscreen</span></button> <button id=bike-obby-close><span class=material-icons>close</span></button></div></div><div id=bike-obby-canvas-container><div class=ad-blocked-iframe><iframe id=bike-obby-frame src=https://maddox05.github.io/basic-ruffle-player/html/obby_but_youre_on_a_bike/index.html style=width:100%;height:100%;border:none></iframe></div></div><div id=bike-obby-stats><div id=bike-obby-score>Playing: Bike Obby</div></div></div></div><div id=minecraft-modal><div id=minecraft-container><div id=minecraft-header><div id=minecraft-title>Minecraft</div><div class=header-controls><button id=minecraft-fullscreen title="Toggle Fullscreen"><span class=material-icons>fullscreen</span></button> <button id=minecraft-close><span class=material-icons>close</span></button></div></div><div id=minecraft-canvas-container><div class=ad-blocked-iframe><iframe id=minecraft-frame src=https://burnoli.github.io/Eaglercraft/1.8.8/ style=width:100%;height:100%;border:none></iframe></div></div><div id=minecraft-stats><div id=minecraft-score>Playing: Minecraft</div></div></div></div><div id=audio-call-container><div id=audio-call-info><img alt="Caller avatar"id=caller-avatar src=""><div id=caller-name></div><div id=call-status>Call in progress...</div></div><div id=call-controls><button id=end-call-btn title="End call"class=call-btn><span class=material-icons>call_end</span></button></div></div><div id=incoming-call-modal><div id=incoming-call-container><h3><span class=material-icons>call</span> Incoming Audio Call</h3><div id=incoming-call-info>Someone is calling you...</div><div id=incoming-call-controls><button id=accept-call-btn class="call-btn accept"><span class=material-icons>call</span></button> <button id=reject-call-btn class=call-btn><span class=material-icons>close</span></button></div></div></div><div id=call-user-modal><div id=call-user-container><h3><span class=material-icons>call</span> Call a User</h3><p>Select who you want to call:<div id=call-user-list></div><div class=call-user-buttons><button id=cancel-call-btn>Cancel</button></div></div></div><div id=microphone-permission-modal><div id=microphone-permission-container><h3><span class=material-icons>mic</span> Microphone Access Required</h3><div id=microphone-permission-info>Audio calls require microphone access. Would you like to allow microphone access?</div><div id=microphone-permission-controls><button id=allow-microphone-btn style=background-color:#38a169>Allow</button> <button id=deny-microphone-btn style=background-color:#e53e3e>Deny</button></div></div></div><div id=file-upload-modal><div id=file-upload-container><h3><span class=material-icons>attach_file</span> Upload File</h3><div id=file-upload-area><div id=file-upload-icon class=material-icons>cloud_upload</div><div id=file-upload-text>Click to upload or drag and drop</div><div id=file-upload-hint>Supports images, videos, and documents (max 10MB)</div></div><input id=file-input type=file style=display:none><div id=file-preview></div><div class=file-upload-buttons><button id=cancel-upload-btn>Cancel</button> <button id=send-file-btn style=background-color:#38a169>Send File</button></div></div></div><div id=gif-sticker-modal><div id=gif-sticker-container><h3><span class=material-icons>gif</span> GIFs & Stickers</h3><div id=gif-sticker-tabs><button class="active gif-sticker-tab"data-tab=gifs>GIFs</button> <button class=gif-sticker-tab data-tab=stickers>Stickers</button></div><div class=gif-search><input id=gif-search-input placeholder="Search for GIFs..."></div><div id=gif-sticker-content><div id=gifs-tab class=gif-sticker-tab-content><div id=gifs-grid class=gif-sticker-grid><div class=gif-loading><span>Search for GIFs above...</span></div></div></div><div id=stickers-tab class="hidden gif-sticker-tab-content"><div id=stickers-grid class=gif-sticker-grid></div></div></div><div class=gif-sticker-buttons><button id=cancel-gif-sticker-btn>Cancel</button></div></div></div><div id=emoji-picker-modal><div id=emoji-picker-container><h3><span class=material-icons>emoji_emotions</span> Add Reaction</h3><div id=emoji-picker-title>Choose an emoji:</div><div id=emoji-picker-grid></div><div class=emoji-picker-buttons><button id=cancel-emoji-btn>Cancel</button></div></div></div><div id=link-share-modal><div id=link-share-container><h3 id=link-share-title><span class=material-icons>link</span> Share a Link</h3><div class=link-share-field><label for=link-url>URL:</label> <input id=link-url placeholder=https://example.com type=url></div><div class=link-share-field><label for=link-display>Display Text (optional):</label> <input id=link-display placeholder="Check this out!"></div><div id=link-preview class="hidden link-preview"><div class=link-preview-title>Preview:</div><div class=link-preview-url></div></div><div class=link-share-buttons><button id=cancel-link-btn>Cancel</button> <button id=insert-link-btn style=background-color:#38a169>Insert Link</button></div></div></div><div id=encryption-key-modal><div id=encryption-key-container><h3><span class=material-icons>lock</span> Encryption Key Generated</h3><p>Save this key to decrypt your messages. Without it, your messages cannot be read.<div id=encryption-key-display></div><div class=encryption-key-buttons><button id=copy-key-btn>Copy Key</button> <button id=enter-key-btn style=background-color:#ed8936>Enter Existing Key</button> <button id=confirm-key-btn style=background-color:#38a169>I've Saved The Key</button></div></div></div><div id=enter-key-modal><div id=enter-key-container><h3><span class=material-icons>key</span> Enter Encryption Key</h3><p>Paste your existing encryption key below:</p><textarea id=encryption-key-input placeholder="Paste your encryption key here..."rows=4></textarea><div class=key-entry-buttons><button id=cancel-key-btn>Cancel</button> <button id=use-key-btn style=background-color:#38a169>Use This Key</button></div></div></div><div id=wallpaper-modal><div id=wallpaper-options></div></div><div id=profile-picture-modal><div id=profile-picture-options></div></div><div id=sw-notification class=sw-notification>Service Worker installed. You can now receive notifications!</div><script>// ==================== PAGE RELOAD PROTECTION ====================
// ADDED: This prevents the page from reloading randomly
(function() {
    'use strict';
    
    console.log('ðŸ›¡ï¸ Initializing page reload protection...');
    
    let reloadPreventionEnabled = true;
    const overlay = document.getElementById('reload-protection-overlay');
    const cancelBtn = document.getElementById('cancel-reload-btn');
    const continueBtn = document.getElementById('continue-reload-btn');
    
    // Prevent accidental browser reload/close
    window.addEventListener('beforeunload', function(e) {
        if (!reloadPreventionEnabled) return;
        
        // Check if we should prevent reload
        const hasUnsavedMessages = document.getElementById('message-input') && document.getElementById('message-input').value.trim() !== '';
        const isInGame = document.querySelector('#game-modal') && document.querySelector('#game-modal').style.display === 'flex' || 
                        document.querySelector('#steal-brainrot-modal') && document.querySelector('#steal-brainrot-modal').style.display === 'flex' ||
                        document.querySelector('#bike-obby-modal') && document.querySelector('#bike-obby-modal').style.display === 'flex' ||
                        document.querySelector('#minecraft-modal') && document.querySelector('#minecraft-modal').style.display === 'flex';
        
        if (hasUnsavedMessages || isInGame || (typeof isInCall !== 'undefined' && isInCall)) {
            e.preventDefault();
            e.returnValue = 'You have unsaved messages or active games. Are you sure you want to leave?';
            
            // Show custom reload protection overlay
            overlay.style.display = 'flex';
            return e.returnValue;
        }
    });
    
    // Handle reload protection buttons
    cancelBtn.addEventListener('click', function() {
        overlay.style.display = 'none';
    });
    
    continueBtn.addEventListener('click', function() {
        reloadPreventionEnabled = false;
        window.location.reload();
    });
    
    // Prevent form submission from causing page reload
    document.addEventListener('submit', function(e) {
        if (e.target && e.target.tagName === 'FORM') {
            e.preventDefault();
        }
    });
    
    // Catch and prevent any unhandled errors that might cause reloads
    window.addEventListener('error', function(e) {
        console.log('ðŸš¨ Error caught (preventing reload):', e.error);
        e.preventDefault();
        return true;
    });
    
    // Catch unhandled promise rejections
    window.addEventListener('unhandledrejection', function(e) {
        console.log('ðŸš¨ Promise rejection caught (preventing reload):', e.reason);
        e.preventDefault();
        return true;
    });
    
    console.log('âœ… Page reload protection activated');
})();

// ==================== ADBLOCKER FUNCTIONALITY ====================
// Your existing code continues exactly as before...
let adblockerEnabled = true;

function initializeAdblocker() {
  console.log('ðŸ›¡ï¸ Initializing adblocker...');
  
  // Load adblocker state from localStorage
  loadAdblockerState();
  
  // Set up adblocker button
  const adblockerBtn = document.getElementById('adblocker-btn');
  const adblockerModal = document.getElementById('adblocker-modal');
  const disableAdblockerBtn = document.getElementById('disable-adblocker-btn');
  const enableAdblockerBtn = document.getElementById('enable-adblocker-btn');
  const closeAdblockerBtn = document.getElementById('close-adblocker-btn');
  
  adblockerBtn.addEventListener('click', () => {
    adblockerModal.style.display = 'flex';
    updateAdblockerStatus();
  });
  
  disableAdblockerBtn.addEventListener('click', () => {
    adblockerEnabled = false;
    saveAdblockerState();
    updateAdblockerUI();
    updateAdblockerStatus();
    showSuccess('Adblocker disabled. Ads may appear in games.');
  });
  
  enableAdblockerBtn.addEventListener('click', () => {
    adblockerEnabled = true;
    saveAdblockerState();
    updateAdblockerUI();
    updateAdblockerStatus();
    showSuccess('Adblocker enabled. Ads will be blocked in games.');
  });
  
  closeAdblockerBtn.addEventListener('click', () => {
    adblockerModal.style.display = 'none';
  });
  
  adblockerModal.addEventListener('click', (e) => {
    if (e.target === adblockerModal) {
      adblockerModal.style.display = 'none';
    }
  });
  
  // Initial UI update
  updateAdblockerUI();
}

// Load adblocker state from localStorage
function loadAdblockerState() {
  const savedState = localStorage.getItem('adblockerEnabled');
  if (savedState !== null) {
    adblockerEnabled = JSON.parse(savedState);
  }
}

// Save adblocker state to localStorage
function saveAdblockerState() {
  localStorage.setItem('adblockerEnabled', JSON.stringify(adblockerEnabled));
}

// Update adblocker UI
function updateAdblockerUI() {
  const adblockerBtn = document.getElementById('adblocker-btn');
  
  if (adblockerEnabled) {
    adblockerBtn.classList.remove('disabled');
    adblockerBtn.title = 'Adblocker: ON';
    adblockerBtn.innerHTML = '<span class="material-icons">block</span>';
  } else {
    adblockerBtn.classList.add('disabled');
    adblockerBtn.title = 'Adblocker: OFF';
    adblockerBtn.innerHTML = '<span class="material-icons">check_circle</span>';
  }
}

// Update adblocker status in modal
function updateAdblockerStatus() {
  const adblockerStatus = document.getElementById('adblocker-status');
  
  if (adblockerEnabled) {
    adblockerStatus.className = 'adblocker-status active';
    adblockerStatus.innerHTML = '<span class="material-icons">check_circle</span><span>Adblocker is currently ACTIVE</span>';
  } else {
    adblockerStatus.className = 'adblocker-status inactive';
    adblockerStatus.innerHTML = '<span class="material-icons">cancel</span><span>Adblocker is currently INACTIVE</span>';
  }
}

// Block ads in iframes
function blockAdsInIframes() {
  if (!adblockerEnabled) return;
  
  // Block common ad domains
  const adDomains = [
    'doubleclick.net',
    'googleadservices.com',
    'googlesyndication.com',
    'google-analytics.com',
    'facebook.com/tr',
    'adsystem',
    'adservice',
    'advertising',
    'tracking',
    'analytics'
  ];
  
  // Apply ad blocking to game iframes
  const gameIframes = document.querySelectorAll('#game-frame, #steal-brainrot-frame, #bike-obby-frame, #minecraft-frame');
  
  gameIframes.forEach(iframe => {
    try {
      // Add a content security policy to block ads
      iframe.setAttribute('csp', "script-src 'self' 'unsafe-inline' 'unsafe-eval'; object-src 'none';");
      
      // Monitor for ad-related requests
      iframe.addEventListener('load', function() {
        try {
          const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
          
          // Block ad scripts
          const scripts = iframeDoc.querySelectorAll('script');
          scripts.forEach(script => {
            const src = script.src.toLowerCase();
            if (adDomains.some(domain => src.includes(domain))) {
              script.remove();
            }
          });
          
          // Block ad iframes
          const iframes = iframeDoc.querySelectorAll('iframe');
          iframes.forEach(innerIframe => {
            const innerSrc = innerIframe.src.toLowerCase();
            if (adDomains.some(domain => innerSrc.includes(domain))) {
              innerIframe.remove();
            }
          });
          
          // Block ad elements by class/id
          const adSelectors = [
            '[class*="ad"]',
            '[id*="ad"]',
            '[class*="banner"]',
            '[id*="banner"]',
            '[class*="sponsor"]',
            '[id*="sponsor"]'
          ];
          
          adSelectors.forEach(selector => {
            const adElements = iframeDoc.querySelectorAll(selector);
            adElements.forEach(el => {
              if (isLikelyAd(el)) {
                el.remove();
              }
            });
          });
        } catch (e) {
          // Cross-origin iframe, can't access content
          console.log('Cannot access iframe content due to CORS');
        }
      });
    } catch (e) {
      console.log('Error blocking ads in iframe:', e);
    }
  });
}

// Check if element is likely an ad
function isLikelyAd(element) {
  const styles = window.getComputedStyle(element);
  const text = element.textContent || '';
  
  // Check for common ad indicators
  return (
    element.offsetWidth > 300 && element.offsetHeight > 250 || // Common ad dimensions
    text.includes('ad') || text.includes('Ad') ||
    text.includes('sponsor') || text.includes('Sponsor') ||
    styles.display === 'none' || // Hidden elements might be tracking pixels
    element.tagName === 'INS' || // Google AdSense
    element.classList.contains('adsbygoogle')
  );
}

// ==================== GAME MODAL ENHANCEMENTS ====================

// Enhanced game modal initialization with fullscreen support
function initializeGameModals() {
  const gameBtn = document.getElementById('game-btn');
  const gameModal = document.getElementById('game-modal');
  const gameClose = document.getElementById('game-close');
  const gameFullscreen = document.getElementById('game-fullscreen');
  const gameContainer = document.getElementById('game-container');

  const stealBrainrotBtn = document.getElementById('steal-brainrot-btn');
  const stealBrainrotModal = document.getElementById('steal-brainrot-modal');
  const stealBrainrotClose = document.getElementById('steal-brainrot-close');
  const stealBrainrotFullscreen = document.getElementById('steal-brainrot-fullscreen');
  const stealBrainrotContainer = document.getElementById('steal-brainrot-container');

  const bikeObbyBtn = document.getElementById('bike-obby-btn');
  const bikeObbyModal = document.getElementById('bike-obby-modal');
  const bikeObbyClose = document.getElementById('bike-obby-close');
  const bikeObbyFullscreen = document.getElementById('bike-obby-fullscreen');
  const bikeObbyContainer = document.getElementById('bike-obby-container');

  // NEW: Minecraft button and modal
  const minecraftBtn = document.getElementById('minecraft-btn');
  const minecraftModal = document.getElementById('minecraft-modal');
  const minecraftClose = document.getElementById('minecraft-close');
  const minecraftFullscreen = document.getElementById('minecraft-fullscreen');
  const minecraftContainer = document.getElementById('minecraft-container');

  // NEW: Insert Link button
  const insertLinkBtn = document.getElementById('insert-link-btn');
  
  // Grow a Garden game
  gameBtn.addEventListener('click', () => {
    gameModal.style.display = 'flex';
    // Apply ad blocking when game loads
    setTimeout(blockAdsInIframes, 100);
  });

  gameClose.addEventListener('click', () => {
    gameModal.style.display = 'none';
    // Exit fullscreen when closing
    if (gameContainer.classList.contains('fullscreen')) {
      gameContainer.classList.remove('fullscreen');
      gameFullscreen.innerHTML = '<span class="material-icons">fullscreen</span>';
      gameFullscreen.title = 'Enter Fullscreen';
    }
  });

  gameModal.addEventListener('click', (e) => {
    if (e.target === gameModal) {
      gameModal.style.display = 'none';
      // Exit fullscreen when closing
      if (gameContainer.classList.contains('fullscreen')) {
        gameContainer.classList.remove('fullscreen');
        gameFullscreen.innerHTML = '<span class="material-icons">fullscreen</span>';
        gameFullscreen.title = 'Enter Fullscreen';
      }
    }
  });

  // Grow a Garden fullscreen functionality
  gameFullscreen.addEventListener('click', () => {
    gameContainer.classList.toggle('fullscreen');
    
    if (gameContainer.classList.contains('fullscreen')) {
      gameFullscreen.innerHTML = '<span class="material-icons">fullscreen_exit</span>';
      gameFullscreen.title = 'Exit Fullscreen';
    } else {
      gameFullscreen.innerHTML = '<span class="material-icons">fullscreen</span>';
      gameFullscreen.title = 'Enter Fullscreen';
    }
  });

  // FIXED: Steal a Brainrot game
  stealBrainrotBtn.addEventListener('click', () => {
    stealBrainrotModal.style.display = 'flex';
    // Apply ad blocking when game loads
    setTimeout(blockAdsInIframes, 100);
  });

  stealBrainrotClose.addEventListener('click', () => {
    stealBrainrotModal.style.display = 'none';
    // Exit fullscreen when closing
    if (stealBrainrotContainer.classList.contains('fullscreen')) {
      stealBrainrotContainer.classList.remove('fullscreen');
      stealBrainrotFullscreen.innerHTML = '<span class="material-icons">fullscreen</span>';
      stealBrainrotFullscreen.title = 'Enter Fullscreen';
    }
  });

  stealBrainrotModal.addEventListener('click', (e) => {
    if (e.target === stealBrainrotModal) {
      stealBrainrotModal.style.display = 'none';
      // Exit fullscreen when closing
      if (stealBrainrotContainer.classList.contains('fullscreen')) {
        stealBrainrotContainer.classList.remove('fullscreen');
        stealBrainrotFullscreen.innerHTML = '<span class="material-icons">fullscreen</span>';
        stealBrainrotFullscreen.title = 'Enter Fullscreen';
      }
    }
  });

  // Steal a Brainrot fullscreen functionality
  stealBrainrotFullscreen.addEventListener('click', () => {
    stealBrainrotContainer.classList.toggle('fullscreen');
    
    if (stealBrainrotContainer.classList.contains('fullscreen')) {
      stealBrainrotFullscreen.innerHTML = '<span class="material-icons">fullscreen_exit</span>';
      stealBrainrotFullscreen.title = 'Exit Fullscreen';
    } else {
      stealBrainrotFullscreen.innerHTML = '<span class="material-icons">fullscreen</span>';
      stealBrainrotFullscreen.title = 'Enter Fullscreen';
    }
  });

  // NEW: Bike Obby game
  bikeObbyBtn.addEventListener('click', () => {
    bikeObbyModal.style.display = 'flex';
    // Apply ad blocking when game loads
    setTimeout(blockAdsInIframes, 100);
  });

  bikeObbyClose.addEventListener('click', () => {
    bikeObbyModal.style.display = 'none';
    // Exit fullscreen when closing
    if (bikeObbyContainer.classList.contains('fullscreen')) {
      bikeObbyContainer.classList.remove('fullscreen');
      bikeObbyFullscreen.innerHTML = '<span class="material-icons">fullscreen</span>';
      bikeObbyFullscreen.title = 'Enter Fullscreen';
    }
  });

  bikeObbyModal.addEventListener('click', (e) => {
    if (e.target === bikeObbyModal) {
      bikeObbyModal.style.display = 'none';
      // Exit fullscreen when closing
      if (bikeObbyContainer.classList.contains('fullscreen')) {
        bikeObbyContainer.classList.remove('fullscreen');
        bikeObbyFullscreen.innerHTML = '<span class="material-icons">fullscreen</span>';
        bikeObbyFullscreen.title = 'Enter Fullscreen';
      }
    }
  });

  // Bike Obby fullscreen functionality
  bikeObbyFullscreen.addEventListener('click', () => {
    bikeObbyContainer.classList.toggle('fullscreen');
    
    if (bikeObbyContainer.classList.contains('fullscreen')) {
      bikeObbyFullscreen.innerHTML = '<span class="material-icons">fullscreen_exit</span>';
      bikeObbyFullscreen.title = 'Exit Fullscreen';
    } else {
      bikeObbyFullscreen.innerHTML = '<span class="material-icons">fullscreen</span>';
      bikeObbyFullscreen.title = 'Enter Fullscreen';
    }
  });

  // NEW: Minecraft game
  minecraftBtn.addEventListener('click', () => {
    minecraftModal.style.display = 'flex';
    // Apply ad blocking when game loads
    setTimeout(blockAdsInIframes, 100);
  });

  minecraftClose.addEventListener('click', () => {
    minecraftModal.style.display = 'none';
    // Exit fullscreen when closing
    if (minecraftContainer.classList.contains('fullscreen')) {
      minecraftContainer.classList.remove('fullscreen');
      minecraftFullscreen.innerHTML = '<span class="material-icons">fullscreen</span>';
      minecraftFullscreen.title = 'Enter Fullscreen';
    }
  });

  minecraftModal.addEventListener('click', (e) => {
    if (e.target === minecraftModal) {
      minecraftModal.style.display = 'none';
      // Exit fullscreen when closing
      if (minecraftContainer.classList.contains('fullscreen')) {
        minecraftContainer.classList.remove('fullscreen');
        minecraftFullscreen.innerHTML = '<span class="material-icons">fullscreen</span>';
        minecraftFullscreen.title = 'Enter Fullscreen';
      }
    }
  });

  // Minecraft fullscreen functionality
  minecraftFullscreen.addEventListener('click', () => {
    minecraftContainer.classList.toggle('fullscreen');
    
    if (minecraftContainer.classList.contains('fullscreen')) {
      minecraftFullscreen.innerHTML = '<span class="material-icons">fullscreen_exit</span>';
      minecraftFullscreen.title = 'Exit Fullscreen';
    } else {
      minecraftFullscreen.innerHTML = '<span class="material-icons">fullscreen</span>';
      minecraftFullscreen.title = 'Enter Fullscreen';
    }
  });

  // NEW: Insert Link button functionality
  insertLinkBtn.addEventListener('click', () => {
    linkShareModal.style.display = 'flex';
    linkUrlInput.value = '';
    linkDisplayInput.value = '';
    linkPreview.classList.add('hidden');
  });

  // Exit fullscreen on Escape key for all games
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      if (gameContainer.classList.contains('fullscreen')) {
        gameContainer.classList.remove('fullscreen');
        gameFullscreen.innerHTML = '<span class="material-icons">fullscreen</span>';
        gameFullscreen.title = 'Enter Fullscreen';
      }
      if (stealBrainrotContainer.classList.contains('fullscreen')) {
        stealBrainrotContainer.classList.remove('fullscreen');
        stealBrainrotFullscreen.innerHTML = '<span class="material-icons">fullscreen</span>';
        stealBrainrotFullscreen.title = 'Enter Fullscreen';
      }
      if (bikeObbyContainer.classList.contains('fullscreen')) {
        bikeObbyContainer.classList.remove('fullscreen');
        bikeObbyFullscreen.innerHTML = '<span class="material-icons">fullscreen</span>';
        bikeObbyFullscreen.title = 'Enter Fullscreen';
      }
      if (minecraftContainer.classList.contains('fullscreen')) {
        minecraftContainer.classList.remove('fullscreen');
        minecraftFullscreen.innerHTML = '<span class="material-icons">fullscreen</span>';
        minecraftFullscreen.title = 'Enter Fullscreen';
      }
    }
  });
}

// ==================== ENHANCED INITIALIZATION ====================

// Enhanced initialization with new features
async function initApp() {
  console.log('ðŸš€ Initializing Enhanced Encrypted Super Chat...');

  try {
    // Initialize user
    initializeUser();
    addNameChangeFeature(); // ADDED: Name change in sidebar

    // Initialize sidebar
    initializeSidebar();

    // Initialize profile pictures
    initializeProfilePictures();

    // Initialize audio call functionality
    initializeAudioCall();

    // Initialize file upload
    initializeFileUpload();

    // Initialize GIF & Sticker functionality
    initializeGifSticker();

    // Initialize emoji picker
    initializeEmojiPicker();

    // Initialize link sharing
    initializeLinkSharing();

    // Initialize text formatting
    initializeTextFormatting();

    // Initialize game modals with enhanced features
    initializeGameModals();

    // Initialize admin panel
    initializeAdminPanel();

    // Initialize adblocker
    initializeAdblocker();

    // Load message reactions
    loadMessageReactions();

    // Load saved wallpaper
    const savedWallpaper = localStorage.getItem("chatWallpaper");
    if (savedWallpaper) {
      applyWallpaper(savedWallpaper);
    }

    // Populate wallpaper options
    wallpapers.forEach(w => {
      const wallpaperContainer = document.createElement("div");
      wallpaperContainer.classList.add("wallpaper-grid");

      const div = document.createElement("div");
      div.classList.add("wallpaper-option");
      div.style.background = w.preview;

      const label = document.createElement("div");
      label.classList.add("wallpaper-label");
      label.textContent = w.name;

      div.addEventListener("click", () => {
        applyWallpaper(w.preview);
        wallpaperModal.style.display = "none";
        showSuccess(`Background changed to ${w.name}!`);
      });

      wallpaperContainer.appendChild(div);
      wallpaperContainer.appendChild(label);
      wallpaperOptions.appendChild(wallpaperContainer);
    });

    // Wallpaper modal logic
    editWallpaperBtn.addEventListener("click", () => {
      wallpaperModal.style.display = "flex";
    });

    wallpaperModal.addEventListener("click", (e) => {
      if (e.target === wallpaperModal) {
        wallpaperModal.style.display = "none";
      }
    });

    // Encryption key modal event listeners
    encryptionKeyModal.addEventListener("click", (e) => {
      if (e.target === encryptionKeyModal) {
        encryptionKeyModal.style.display = "none";
      }
    });

    enterKeyModal.addEventListener("click", (e) => {
      if (e.target === enterKeyModal) {
        enterKeyModal.style.display = "none";
      }
    });

    // Call user modal event listener
    callUserModal.addEventListener("click", (e) => {
      if (e.target === callUserModal) {
        callUserModal.style.display = "none";
      }
    });

    // Microphone permission modal event listener
    microphonePermissionModal.addEventListener("click", (e) => {
      if (e.target === microphonePermissionModal) {
        microphonePermissionModal.style.display = "none";
      }
    });

    // Link share modal event listener
    linkShareModal.addEventListener("click", (e) => {
      if (e.target === linkShareModal) {
        linkShareModal.style.display = 'none';
      }
    });

    // Security indicator click to manage key
    securityIndicator.addEventListener("click", showCurrentKey);

    // Load messages for current server - FIXED: Load immediately
    loadServerMessages(currentServer);
    await loadMessages();

    // Setup message read tracking
    setupMessageReadTracking();

    // Start polling for new messages
    startPolling();

    console.log('âœ… Encrypted Super Chat initialized successfully');
    showTemporaryStatus('âœ… Encrypted Super Chat ready!');

  } catch (error) {
    console.error('âŒ App initialization failed:', error);
    showError('Failed to initialize. Please refresh the page.');
  }
}

// ==================== NAME CHANGE FEATURE ====================

// Add name change functionality to sidebar user name
function addNameChangeFeature() {
  const userSidebarName = document.getElementById('user-sidebar-name');
  
  userSidebarName.addEventListener('click', async function() {
    const newName = prompt("Enter your new name:", userName) || userName;
    const cleanedName = newName.trim();

    if (cleanedName && cleanedName !== userName) {
      try {
        // Update all messages with the new name in the database
        const messagesToUpdate = allMessages.filter(msg => msg.user_id === userId);

        for (const message of messagesToUpdate) {
          await serverFetch(currentServer, `messages?id=eq.${message.id}`, {
            method: 'PATCH',
            body: JSON.stringify({
              user_name: cleanedName
            })
          });
        }

        // Update local state
        userName = cleanedName;
        localStorage.setItem('chatUserName', userName);
        userDisplay.textContent = `You: ${userName}`;

        // Update all messages with new name in UI WITHOUT clearing page
        updateAllMessagesWithUserName();
        // Update sidebar
        updateUserSection();

        showSuccess(`Name updated to ${userName}!`);

      } catch (error) {
        console.error('Error updating name:', error);
        showError('Failed to update name. Please try again.');
      }
    }
  });
}

// ==================== YOUR EXISTING JAVASCRIPT CODE ====================
// All your existing JavaScript code remains exactly the same...
// I'm preserving all your original code structure and just adding the new functionality

// ==================== ADMIN PANEL FUNCTIONALITY ====================

// Admin password - KEEP THIS SECURE!
const ADMIN_PASSWORD = "chat-app25"; // Changed to chat-app25

// Rank system
const RANKS = {
  'user': { name: 'User', color: '#718096' },
  'moderator': { name: 'Moderator', color: '#4299e1' },
  'admin': { name: 'Admin', color: '#e53e3e' },
  'owner': { name: 'Owner', color: '#d69e2e' }
};

// User ranks storage
let userRanks = {};

// Current admin state
let isAdmin = false;
let selectedRank = 'user';

// Initialize admin panel
function initializeAdminPanel() {
  console.log('ðŸ”§ Initializing admin panel...');
  
  // Load user ranks from localStorage
  loadUserRanks();
  
  // Set up admin panel button
  const adminPanelBtn = document.getElementById('admin-panel-btn');
  const adminModal = document.getElementById('admin-modal');
  const adminLoginBtn = document.getElementById('admin-login-btn');
  const adminCancelBtn = document.getElementById('admin-cancel-btn');
  const adminCloseBtn = document.getElementById('admin-close-btn');
  const adminPasswordInput = document.getElementById('admin-password-input');
  
  adminPanelBtn.addEventListener('click', () => {
    adminModal.style.display = 'flex';
    document.getElementById('admin-login').classList.remove('hidden');
    document.getElementById('admin-content').classList.add('hidden');
    adminPasswordInput.value = '';
  });
  
  adminLoginBtn.addEventListener('click', authenticateAdmin);
  adminCancelBtn.addEventListener('click', () => {
    adminModal.style.display = 'none';
  });
  
  adminCloseBtn.addEventListener('click', () => {
    adminModal.style.display = 'none';
    isAdmin = false;
  });
  
  adminPasswordInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      authenticateAdmin();
    }
  });
  
  adminModal.addEventListener('click', (e) => {
    if (e.target === adminModal) {
      adminModal.style.display = 'none';
      isAdmin = false;
    }
  });
  
  // Initialize rank controls
  initializeRankControls();
}

// Authenticate admin - automatically grant admin role
function authenticateAdmin() {
  const passwordInput = document.getElementById('admin-password-input');
  const enteredPassword = passwordInput.value.trim();
  
  if (enteredPassword === ADMIN_PASSWORD) {
    isAdmin = true;
    // Automatically assign admin role to current user
    setUserRank(userId, 'admin');
    document.getElementById('admin-login').classList.add('hidden');
    document.getElementById('admin-content').classList.remove('hidden');
    populateAdminUserList();
    showSuccess('Admin access granted! You now have admin privileges.');
  } else {
    showError('Invalid admin password!');
    passwordInput.value = '';
  }
}

// Initialize rank controls
function initializeRankControls() {
  const rankControls = document.getElementById('admin-rank-controls');
  rankControls.innerHTML = '';
  
  Object.entries(RANKS).forEach(([rankKey, rankData]) => {
    const rankOption = document.createElement('div');
    rankOption.classList.add('rank-option');
    rankOption.setAttribute('data-rank', rankKey);
    
    const rankColor = document.createElement('div');
    rankColor.classList.add('rank-color');
    rankColor.style.backgroundColor = rankData.color;
    
    const rankName = document.createElement('div');
    rankName.classList.add('rank-name');
    rankName.textContent = rankData.name;
    
    rankOption.appendChild(rankColor);
    rankOption.appendChild(rankName);
    
    rankOption.addEventListener('click', () => {
      selectedRank = rankKey;
      document.querySelectorAll('.rank-option').forEach(opt => {
        opt.classList.remove('selected');
      });
      rankOption.classList.add('selected');
    });
    
    rankControls.appendChild(rankOption);
  });
  
  // Select default rank
  document.querySelector('.rank-option[data-rank="user"]').classList.add('selected');
}

// Populate admin user list
function populateAdminUserList() {
  const adminUserList = document.getElementById('admin-user-list');
  adminUserList.innerHTML = '';
  
  // Get all unique users from messages
  const users = getUniqueUsersFromMessages();
  
  if (users.length === 0) {
    const noUsers = document.createElement('div');
    noUsers.textContent = 'No users found';
    noUsers.style.textAlign = 'center';
    noUsers.style.padding = '20px';
    noUsers.style.color = '#666';
    adminUserList.appendChild(noUsers);
    return;
  }
  
  users.forEach(user => {
    const userItem = document.createElement('div');
    userItem.classList.add('admin-user-item');
    
    const userInfo = document.createElement('div');
    userInfo.classList.add('admin-user-info');
    
    const avatar = document.createElement('img');
    avatar.classList.add('admin-user-avatar');
    avatar.src = user.avatar;
    avatar.alt = `${user.name}'s avatar`;
    
    const userDetails = document.createElement('div');
    userDetails.classList.add('admin-user-details');
    
    const userName = document.createElement('div');
    userName.classList.add('admin-user-name');
    userName.textContent = user.name;
    
    const userRank = document.createElement('div');
    userRank.classList.add('admin-user-rank');
    const userRankData = getUserRank(user.id);
    userRank.textContent = userRankData.name;
    userRank.style.backgroundColor = userRankData.color;
    userRank.style.color = 'white';
    
    userDetails.appendChild(userName);
    userDetails.appendChild(userRank);
    userInfo.appendChild(avatar);
    userInfo.appendChild(userDetails);
    
    const userControls = document.createElement('div');
    userControls.classList.add('admin-user-controls');
    
    // Don't show delete button for current user
    if (user.id !== userId) {
      const deleteBtn = document.createElement('button');
      deleteBtn.classList.add('admin-btn', 'delete');
      deleteBtn.textContent = 'Delete';
      deleteBtn.addEventListener('click', () => {
        deleteUser(user.id, user.name);
      });
      userControls.appendChild(deleteBtn);
    }
    
    const promoteBtn = document.createElement('button');
    promoteBtn.classList.add('admin-btn', 'promote');
    promoteBtn.textContent = 'Set Rank';
    promoteBtn.addEventListener('click', () => {
      setUserRank(user.id, selectedRank);
      populateAdminUserList(); // Refresh the list
    });
    userControls.appendChild(promoteBtn);
    
    // Add admin promotion button if user is not already admin
    if (getUserRank(user.id).key !== 'admin' && getUserRank(user.id).key !== 'owner') {
      const makeAdminBtn = document.createElement('button');
      makeAdminBtn.classList.add('admin-btn', 'promote');
      makeAdminBtn.textContent = 'Make Admin';
      makeAdminBtn.addEventListener('click', () => {
        setUserRank(user.id, 'admin');
        populateAdminUserList(); // Refresh the list
      });
      userControls.appendChild(makeAdminBtn);
    }
    
    userItem.appendChild(userInfo);
    userItem.appendChild(userControls);
    adminUserList.appendChild(userItem);
  });
}

// Get user rank
function getUserRank(userId) {
  const rankKey = userRanks[userId] || 'user';
  return {
    key: rankKey,
    name: RANKS[rankKey].name,
    color: RANKS[rankKey].color
  };
}

// Set user rank
function setUserRank(userId, rank) {
  userRanks[userId] = rank;
  saveUserRanks();
  
  // Update UI if the user is in the sidebar
  updateUserRankInSidebar(userId);
  
  showSuccess(`Rank updated for user`);
}

// Delete user
function deleteUser(userId, userName) {
  if (!confirm(`Are you sure you want to delete user "${userName}"? This will remove all their messages.`)) {
    return;
  }
  
  // Remove user's messages from local storage
  allMessages = allMessages.filter(msg => msg.user_id !== userId);
  
  // Update UI
  document.querySelectorAll(`.message-container[data-user-id="${userId}"]`).forEach(el => {
    el.remove();
  });
  
  // Update DM list
  updateDMList();
  
  showSuccess(`User "${userName}" has been deleted`);
  populateAdminUserList(); // Refresh admin list
}

// Update user rank in sidebar
function updateUserRankInSidebar(userId) {
  const dmItems = document.querySelectorAll(`.dm-item[data-user-id="${userId}"]`);
  dmItems.forEach(item => {
    const rankElement = item.querySelector('.user-rank');
    if (rankElement) {
      const rank = getUserRank(userId);
      rankElement.textContent = rank.name;
      rankElement.style.color = rank.color;
    }
  });
}

// Load user ranks from localStorage
function loadUserRanks() {
  const savedRanks = localStorage.getItem('userRanks');
  if (savedRanks) {
    try {
      userRanks = JSON.parse(savedRanks);
    } catch (error) {
      console.error('Error loading user ranks:', error);
      userRanks = {};
    }
  } else {
    userRanks = {};
  }
}

// Save user ranks to localStorage
function saveUserRanks() {
  localStorage.setItem('userRanks', JSON.stringify(userRanks));
}

// Enhanced renderMessage function to show ranks
async function renderMessage(text, senderId, senderName, timestamp = null, messageId = null, editedAt = null, scroll = true, messageData = null) {
  // Check if this message already exists in the DOM to prevent duplicates
  if (messageId && document.querySelector(`[data-message-id="${messageId}"]`)) {
    console.log('âš ï¸ Message already rendered, skipping:', messageId);
    return;
  }

  if (loadingDiv && loadingDiv.parentNode) loadingDiv.remove();

  // Update lastMessageId if this is a new message
  if (messageId && messageId > lastMessageId) {
    lastMessageId = messageId;
  }

  // Add date separator if needed
  if (timestamp) {
    addDateSeparatorIfNeeded(timestamp);
  }

  // Handle different message types
  const messageType = messageData?.type || 'text';

  const container = document.createElement('div');
  container.classList.add('message-container');
  container.classList.add(senderId === userId ? 'self' : 'other');
  if (messageId) container.setAttribute('data-message-id', messageId);

  const messageContent = document.createElement('div');
  messageContent.classList.add('message-content');

  // Add profile picture
  const avatar = document.createElement('img');
  avatar.classList.add('message-avatar');

  // Use user's profile picture for own messages, generated for others
  if (senderId === userId) {
    avatar.src = userProfilePicture;
  } else {
    // Generate a consistent avatar for other users based on their name
    avatar.src = generateAvatar(senderName);
  }

  avatar.alt = `${senderName}'s profile picture`;

  const messageBubble = document.createElement('div');
  messageBubble.classList.add('message-bubble');

  const nameDiv = document.createElement('div');
  nameDiv.classList.add('sender-name');
  const displayName = senderId === userId ? 'You' : senderName;

  // Format timestamp - use edited time if available
  const displayTime = editedAt ? formatTime(editedAt) : formatTime(timestamp);
  const editedText = editedAt ? ' - Edited' : '';
  
  // Add rank to sender name if they have one
  const userRank = getUserRank(senderId);
  let rankHTML = '';
  if (userRank.key !== 'user') {
    rankHTML = ` <span style="color: ${userRank.color}; font-weight: bold;">[${userRank.name}]</span>`;
  }
  
  nameDiv.innerHTML = `${displayName}${rankHTML} â€¢ ${displayTime}${editedText}`;

  const msgDiv = document.createElement('div');
  msgDiv.classList.add('message');
  msgDiv.classList.add(senderId === userId ? 'self' : 'other');

  // Apply rank color to message - FIXED: Proper color application for all ranks
  if (userRank.key !== 'user') {
    if (senderId === userId) {
      // For own messages, use the rank color as background
      msgDiv.style.backgroundColor = userRank.color;
      msgDiv.style.color = 'white';
      // Ensure links are visible
      msgDiv.querySelectorAll('a').forEach(link => {
        link.style.color = 'white';
        link.style.textDecoration = 'underline';
      });
    } else {
      // For others' messages, use a border and ensure text is readable
      msgDiv.style.borderLeft = `3px solid ${userRank.color}`;
      msgDiv.style.backgroundColor = '#e2e8f0'; // Default background for others
      msgDiv.style.color = '#2d3748'; // Default text color for others
    }
  }

  // Handle different message types
  if (messageType === 'text') {
    // Parse Markdown formatting
    const messageWithFormatting = parseMarkdown(text);
    // Parse and render links in the message
    const messageWithLinks = parseAndRenderLinks(messageWithFormatting);
    msgDiv.innerHTML = messageWithLinks;
  } else if (messageType === 'file') {
    // Show file attachment
    if (messageData.text) {
      const textDiv = document.createElement('div');
      textDiv.innerHTML = parseMarkdown(messageData.text);
      textDiv.style.marginBottom = '8px';
      msgDiv.appendChild(textDiv);
    }

    const attachment = document.createElement('div');
    attachment.classList.add('attachment');

    const fileType = messageData.fileType.split('/')[0];
    if (fileType === 'image') {
      const img = document.createElement('img');
      img.src = messageData.fileUrl;
      img.alt = messageData.fileName;
      img.onload = function() {
        console.log('âœ… Image loaded successfully:', messageData.fileUrl);
      };
      img.onerror = function() {
        console.error('âŒ Failed to load image:', messageData.fileUrl);
        img.alt = 'Failed to load image';
        img.style.backgroundColor = '#f7fafc';
        img.style.padding = '20px';
        img.style.textAlign = 'center';
      };
      attachment.appendChild(img);
    } else if (fileType === 'video') {
      const video = document.createElement('video');
      video.src = messageData.fileUrl;
      video.controls = true;
      video.onloadeddata = function() {
        console.log('âœ… Video loaded successfully:', messageData.fileUrl);
      };
      video.onerror = function() {
        console.error('âŒ Failed to load video:', messageData.fileUrl);
      };
      attachment.appendChild(video);
    } else {
      const fileElement = document.createElement('div');
      fileElement.classList.add('attachment-file');

      const icon = document.createElement('span');
      icon.classList.add('material-icons', 'file-icon');
      icon.textContent = 'insert_drive_file';

      const info = document.createElement('div');
      info.classList.add('file-info');

      const name = document.createElement('div');
      name.classList.add('file-name');
      name.textContent = messageData.fileName;

      const size = document.createElement('div');
      size.classList.add('file-size');
      size.textContent = formatFileSize(messageData.fileSize);

      info.appendChild(name);
      info.appendChild(size);
      fileElement.appendChild(icon);
      fileElement.appendChild(info);

      const downloadBtn = document.createElement('button');
      downloadBtn.classList.add('download-btn');
      downloadBtn.innerHTML = '<span class="material-icons">download</span>';
      downloadBtn.title = 'Download file';
      downloadBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        downloadFile(messageData.fileUrl, messageData.fileName);
      });

      fileElement.appendChild(downloadBtn);
      attachment.appendChild(fileElement);
    }

    msgDiv.appendChild(attachment);
  } else if (messageType === 'gif') {
    // Show GIF
    if (messageData.text) {
      const textDiv = document.createElement('div');
      textDiv.innerHTML = parseMarkdown(messageData.text);
      textDiv.style.marginBottom = '8px';
      msgDiv.appendChild(textDiv);
    }

    const gifContainer = document.createElement('div');
    gifContainer.classList.add('attachment');

    const gifImg = document.createElement('img');
    gifImg.src = messageData.gifUrl;
    gifImg.alt = 'GIF';
    gifImg.style.maxWidth = '300px';
    gifImg.style.borderRadius = '8px';
    gifImg.onload = function() {
      console.log('âœ… GIF loaded successfully:', messageData.gifUrl);
    };
    gifImg.onerror = function() {
      console.error('âŒ Failed to load GIF:', messageData.gifUrl);
    };

    gifContainer.appendChild(gifImg);
    msgDiv.appendChild(gifContainer);
  } else if (messageType === 'sticker') {
    // Show sticker
    if (messageData.text) {
      const textDiv = document.createElement('div');
      textDiv.innerHTML = parseMarkdown(messageData.text);
      textDiv.style.marginBottom = '8px';
      msgDiv.appendChild(textDiv);
    }

    const stickerContainer = document.createElement('div');
    stickerContainer.classList.add('attachment');

    const stickerImg = document.createElement('img');
    stickerImg.src = messageData.stickerUrl;
    stickerImg.alt = 'Sticker';
    stickerImg.style.maxWidth = '150px';
    stickerImg.style.borderRadius = '8px';
    stickerImg.onload = function() {
      console.log('âœ… Sticker loaded successfully:', messageData.stickerUrl);
    };
    stickerImg.onerror = function() {
      console.error('âŒ Failed to load sticker:', messageData.stickerUrl);
    };

    stickerContainer.appendChild(stickerImg);
    msgDiv.appendChild(stickerContainer);
  }

  // Add message dropdown
  const dropdown = document.createElement('div');
  dropdown.className = 'message-dropdown';
  
  if (senderId === userId) {
    // Own message: edit, delete, react
    dropdown.innerHTML = `
      <button class="message-dropdown-item reaction" data-action="react">
        <span class="material-icons">add_reaction</span>
        React
      </button>
      <button class="message-dropdown-item" data-action="edit">
        <span class="material-icons">edit</span>
        Edit
      </button>
      <button class="message-dropdown-item delete" data-action="delete">
        <span class="material-icons">delete</span>
        Delete
      </button>
    `;
  } else {
    // Others' message: react only (unless admin)
    if (isAdmin) {
      dropdown.innerHTML = `
        <button class="message-dropdown-item reaction" data-action="react">
          <span class="material-icons">add_reaction</span>
          React
        </button>
        <button class="message-dropdown-item delete" data-action="delete">
          <span class="material-icons">delete</span>
          Delete
        </button>
      `;
    } else {
      dropdown.innerHTML = `
        <button class="message-dropdown-item reaction" data-action="react">
          <span class="material-icons">add_reaction</span>
          React
        </button>
      `;
    }
  }

  // Add event listeners to dropdown items
  dropdown.querySelectorAll('.message-dropdown-item').forEach(item => {
    item.addEventListener('click', (e) => {
      e.stopPropagation();
      const action = item.getAttribute('data-action');
      handleMessageAction(action, messageId, text, senderId);
    });
  });

  container.appendChild(dropdown);

  // Arrange elements based on message type
  if (senderId === userId) {
    // Own message: avatar on right
    messageBubble.appendChild(nameDiv);
    messageBubble.appendChild(msgDiv);
    messageContent.appendChild(messageBubble);
    messageContent.appendChild(avatar);
  } else {
    // Other's message: avatar on left
    messageContent.appendChild(avatar);
    messageBubble.appendChild(nameDiv);
    messageBubble.appendChild(msgDiv);
    messageContent.appendChild(messageBubble);
  }

  container.appendChild(messageContent);
  
  // Add reactions if they exist
  if (messageReactions[messageId]) {
    updateMessageReactions(messageId);
  }

  messagesDiv.appendChild(container);

  if (scroll) {
    scrollToBottom();
  }
}

// Enhanced handleMessageAction to allow admins to delete any message
function handleMessageAction(action, messageId, currentText, senderId) {
  switch(action) {
    case 'react':
      showEmojiPicker(messageId);
      break;
    case 'edit':
      startEditingMessage(messageId, currentText);
      break;
    case 'delete':
      // Allow deletion if it's your own message or if you're an admin
      if (senderId === userId || isAdmin) {
        deleteMessage(messageId);
      } else {
        showError('You can only delete your own messages');
      }
      break;
  }
}

// Enhanced updateDMList to show ranks
function updateDMList() {
  // Get all unique users from messages
  const users = getUniqueUsersFromMessages();

  // Filter out current user but show ALL other users (both online and offline)
  const otherUsers = users.filter(user => user.id !== userId);

  // Update DM list
  dmList.innerHTML = '';

  if (otherUsers.length === 0) {
    const noUsers = document.createElement('div');
    noUsers.textContent = 'No other users yet';
    noUsers.style.textAlign = 'center';
    noUsers.style.padding = '20px';
    noUsers.style.color = '#666';
    dmList.appendChild(noUsers);
  } else {
    otherUsers.forEach(user => {
      const dmItem = document.createElement('div');
      dmItem.classList.add('dm-item');
      if (currentDM && currentDM.id === user.id) {
        dmItem.classList.add('active');
      }
      dmItem.setAttribute('data-user-id', user.id);

      const avatar = document.createElement('div');
      avatar.classList.add('dm-avatar');

      const img = document.createElement('img');
      img.src = user.avatar;
      img.alt = `${user.name}'s avatar`;
      avatar.appendChild(img);

      const info = document.createElement('div');
      info.classList.add('dm-info');

      const name = document.createElement('div');
      name.classList.add('dm-name');
      name.textContent = user.name;

      const status = document.createElement('div');
      status.classList.add('dm-status');
      
      // Check if user is online or offline
      if (onlineUsers.has(user.id)) {
        status.classList.add('online');
        status.textContent = 'Online';
      } else {
        status.classList.add('offline');
        status.textContent = 'Offline';
      }
      
      // Add rank display
      const userRank = getUserRank(user.id);
      if (userRank.key !== 'user') {
        const rank = document.createElement('div');
        rank.classList.add('user-rank');
        rank.textContent = rank.name;
        rank.style.color = rank.color;
        rank.style.fontSize = '0.7rem';
        rank.style.fontWeight = 'bold';
        info.appendChild(rank);
      }

      info.appendChild(name);
      info.appendChild(status);

      dmItem.appendChild(avatar);
      dmItem.appendChild(info);

      dmItem.addEventListener('click', () => {
        // Only allow DM selection when in DM server
        if (currentServer === 'dms') {
          selectDM(user);
        }
      });

      dmList.appendChild(dmItem);
    });
  }
}

// ==================== REAL ENCRYPTION IMPLEMENTATION ====================

// AES-256-GCM Encryption using Web Crypto API
class RealEncryption {
  constructor() {
    this.algorithm = 'AES-GCM';
    this.keyLength = 256;
    this.ivLength = 12; // 96 bits for GCM
  }

  // Generate a real encryption key
  async generateKey() {
    try {
      const key = await crypto.subtle.generateKey(
        {
          name: this.algorithm,
          length: this.keyLength
        },
        true,
        ['encrypt', 'decrypt']
      );
      
      // Export the key as raw bytes
      const exported = await crypto.subtle.exportKey('raw', key);
      const keyBytes = new Uint8Array(exported);
      
      // Convert to hex string for storage
      return Array.from(keyBytes).map(b => b.toString(16).padStart(2, '0')).join('');
    } catch (error) {
      console.error('Key generation failed:', error);
      throw error;
    }
  }

  // Import key from hex string
  async importKey(hexString) {
    try {
      const keyBytes = new Uint8Array(hexString.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
      return await crypto.subtle.importKey(
        'raw',
        keyBytes,
        {
          name: this.algorithm,
          length: this.keyLength
        },
        true,
        ['encrypt', 'decrypt']
      );
    } catch (error) {
      console.error('Key import failed:', error);
      throw error;
    }
  }

  // Encrypt message
  async encrypt(message, keyHex) {
    try {
      const key = await this.importKey(keyHex);
      const iv = crypto.getRandomValues(new Uint8Array(this.ivLength));
      const encoder = new TextEncoder();
      const data = encoder.encode(message);

      const encrypted = await crypto.subtle.encrypt(
        {
          name: this.algorithm,
          iv: iv
        },
        key,
        data
      );

      // Combine IV and encrypted data
      const result = new Uint8Array(iv.length + encrypted.byteLength);
      result.set(iv, 0);
      result.set(new Uint8Array(encrypted), iv.length);

      // Convert to base64 for storage
      return btoa(String.fromCharCode(...result));
    } catch (error) {
      console.error('Encryption failed:', error);
      throw error;
    }
  }

  // Decrypt message
  async decrypt(encryptedData, keyHex) {
    try {
      const key = await this.importKey(keyHex);
      
      // Convert from base64
      const encryptedBytes = new Uint8Array(atob(encryptedData).split('').map(c => c.charCodeAt(0)));
      
      // Extract IV and encrypted data
      const iv = encryptedBytes.slice(0, this.ivLength);
      const data = encryptedBytes.slice(this.ivLength);

      const decrypted = await crypto.subtle.decrypt(
        {
          name: this.algorithm,
          iv: iv
        },
        key,
        data
      );

      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
    } catch (error) {
      console.error('Decryption failed:', error);
      throw error;
    }
  }

  // Generate a secure random key for production
  generateProductionKey() {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+-=[]{}|;:,.<>?';
    let result = '';
    const cryptoArray = new Uint32Array(64);
    crypto.getRandomValues(cryptoArray);
    for (let i = 0; i < 64; i++) {
      result += chars.charAt(cryptoArray[i] % chars.length);
    }
    return result;
  }
}

// Initialize encryption system
const encryption = new RealEncryption();

// ==================== AUDIO CALL IMPLEMENTATION GUIDE ====================
/*
For real audio call functionality, you would need:

1. WebRTC Implementation:
   - Use RTCPeerConnection for peer-to-peer audio
   - STUN/TURN servers for NAT traversal
   - Signaling server to exchange connection details

2. Backend Requirements:
   - WebSocket server for real-time signaling
   - User presence tracking
   - Call state management

3. Key Components:
   - getUserMedia() for microphone access
   - RTCPeerConnection for peer connections
   - RTCDataChannel for additional data (optional)

Example implementation structure:

async function startAudioCall(targetUserId) {
  try {
    // Get local audio stream
    localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    
    // Create peer connection
    peerConnection = new RTCPeerConnection(rtcConfiguration);
    
    // Add local stream to connection
    localStream.getTracks().forEach(track => {
      peerConnection.addTrack(track, localStream);
    });
    
    // Handle incoming stream
    peerConnection.ontrack = (event) => {
      remoteStream = event.streams[0];
      // Play remote audio
      const audioElement = new Audio();
      audioElement.srcObject = remoteStream;
      audioElement.play();
    };
    
    // Create and send offer
    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);
    
    // Send offer to target user via signaling server
    sendSignalingMessage({
      type: 'offer',
      target: targetUserId,
      offer: offer
    });
    
  } catch (error) {
    console.error('Error starting call:', error);
  }
}
*/

// ==================== SUPABASE CONFIGURATION ====================

// Main chat server (for home server)
const supabaseUrl = 'https://igiylouxthnackhbjdrz.supabase.co';
const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlnaXlsb3V4dGhuYWNraGJqZHJ6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAzNzU0MjMsImV4cCI6MjA3NTk1MTQyM30.eaNIKlRV-hs2F1rbbyK30PbL-ON99InD1IFSDwVv8pA';

// Separate Supabase instances for different servers
const serverConfigs = {
  'home': {
    url: 'https://igiylouxthnackhbjdrz.supabase.co',
    key: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlnaXlsb3V4dGhuYWNraGJqZHJ6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAzNzU0MjMsImV4cCI6MjA3NTk1MTQyM30.eaNIKlRV-hs2F1rbbyK30PbL-ON99InD1IFSDwVv8pA'
  }
};

// Giphy API configuration
const GIPHY_API_KEY = 'VfLXE9JQxmGFAhfkbqklLaMdG9JEOsU9';
const GIPHY_BASE_URL = 'https://api.giphy.com/v1/gifs';

// DOM elements
const messagesDiv = document.getElementById('messages');
const form = document.getElementById('chat-form');
const input = document.getElementById('message-input');
const sendButton = document.getElementById('send-button');
const loadingDiv = document.getElementById('loading');
const userDisplay = document.getElementById('user-display');
const statusDiv = document.getElementById('status');
const errorMessage = document.getElementById('error-message');
const successMessage = document.getElementById('success-message');
const editWallpaperBtn = document.getElementById('edit-wallpaper');
const wallpaperModal = document.getElementById('wallpaper-modal');
const wallpaperOptions = document.getElementById('wallpaper-options');
const encryptionKeyModal = document.getElementById('encryption-key-modal');
const encryptionKeyDisplay = document.getElementById('encryption-key-display');
const copyKeyBtn = document.getElementById('copy-key-btn');
const confirmKeyBtn = document.getElementById('confirm-key-btn');
const enterKeyBtn = document.getElementById('enter-key-btn');
const enterKeyModal = document.getElementById('enter-key-modal');
const encryptionKeyInput = document.getElementById('encryption-key-input');
const cancelKeyBtn = document.getElementById('cancel-key-btn');
const useKeyBtn = document.getElementById('use-key-btn');
const securityIndicator = document.getElementById('security-indicator');
const audioCallBtn = document.getElementById('audio-call-btn');
const clearMessagesBtn = document.getElementById('clear-messages-btn');
const profilePictureBtn = document.getElementById('profile-picture-btn');
const profilePictureModal = document.getElementById('profile-picture-modal');
const profilePictureOptions = document.getElementById('profile-picture-options');
const typingIndicator = document.getElementById('typing-indicator');
const typingText = document.getElementById('typing-text');
const linkShareBtn = document.getElementById('link-share-btn');
const linkShareModal = document.getElementById('link-share-modal');
const linkUrlInput = document.getElementById('link-url');
const linkDisplayInput = document.getElementById('link-display');
const linkPreview = document.getElementById('link-preview');
const linkPreviewUrl = document.querySelector('.link-preview-url');
const cancelLinkBtn = document.getElementById('cancel-link-btn');
const insertLinkBtn = document.getElementById('insert-link-btn');

// Text formatting elements
const boldBtn = document.getElementById('bold-btn');
const italicBtn = document.getElementById('italic-btn');

// Sidebar elements
const dmList = document.getElementById('dm-list');
const userSidebarName = document.getElementById('user-sidebar-name');
const userSidebarTag = document.getElementById('user-sidebar-tag');
const userSidebarAvatar = document.getElementById('user-sidebar-avatar');
const serverIcons = document.querySelectorAll('.server-icon');

// Audio call elements
const audioCallContainer = document.getElementById('audio-call-container');
const callerAvatar = document.getElementById('caller-avatar');
const callerName = document.getElementById('caller-name');
const endCallBtn = document.getElementById('end-call-btn');
const incomingCallModal = document.getElementById('incoming-call-modal');
const acceptCallBtn = document.getElementById('accept-call-btn');
const rejectCallBtn = document.getElementById('reject-call-btn');
const callStatus = document.getElementById('call-status');

// Call user selection elements
const callUserModal = document.getElementById('call-user-modal');
const callUserList = document.getElementById('call-user-list');
const cancelCallBtn = document.getElementById('cancel-call-btn');

// Microphone permission elements
const microphonePermissionModal = document.getElementById('microphone-permission-modal');
const allowMicrophoneBtn = document.getElementById('allow-microphone-btn');
const denyMicrophoneBtn = document.getElementById('deny-microphone-btn');

// Emoji picker elements
const emojiPickerModal = document.getElementById('emoji-picker-modal');
const emojiPickerGrid = document.getElementById('emoji-picker-grid');
const cancelEmojiBtn = document.getElementById('cancel-emoji-btn');

// File upload elements
const fileUploadModal = document.getElementById('file-upload-modal');
const fileUploadArea = document.getElementById('file-upload-area');
const fileInput = document.getElementById('file-input');
const filePreview = document.getElementById('file-preview');
const cancelUploadBtn = document.getElementById('cancel-upload-btn');
const sendFileBtn = document.getElementById('send-file-btn');
const fileUploadBtn = document.getElementById('file-upload-btn');

// GIF & Sticker elements
const gifStickerModal = document.getElementById('gif-sticker-modal');
const gifStickerTabs = document.querySelectorAll('.gif-sticker-tab');
const gifsGrid = document.getElementById('gifs-grid');
const stickersGrid = document.getElementById('stickers-grid');
const cancelGifStickerBtn = document.getElementById('cancel-gif-sticker-btn');
const gifStickerBtn = document.getElementById('gif-sticker-btn');
const gifSearchInput = document.getElementById('gif-search-input');

// App state
let userName = null;
let userId = null;
let lastMessageId = 0;
let pollInterval;
let isOnline = false;
let allMessages = [];
let encryptionKey = null;
let decryptionSuccessCount = 0;
let decryptionFailureCount = 0;
let editingMessageId = null;

// Profile picture state
let userProfilePicture = null;

// Audio call state
let localStream = null;
let remoteStream = null;
let peerConnection = null;
let isInCall = false;
let isCallInitiator = false;
let callTargetUserId = null;
let callTargetUserName = null;
let callTargetUserAvatar = null;

// Typing indicators state
let typingUsers = new Set();
let typingTimeout = null;
let lastTypingTime = 0;

// Status message timeout
let statusTimeout = null;

// Track the last date we added a separator for
let lastDateSeparator = null;

// Track online users
let onlineUsers = new Set();

// Track last read message
let lastReadMessageId = localStorage.getItem('lastReadMessageId') || 0;

// Current DM state
let currentDM = null;
let currentServer = 'home';

// DM messages storage
let dmMessages = {};

// Server messages storage
let serverMessages = {};

// Message reactions storage
let messageReactions = {};

// Call notifications storage
let callNotifications = new Map();

// File upload state
let currentFile = null;

// Emoji reactions state
let currentReactingMessageId = null;
const availableEmojis = ['ðŸ‘', 'â¤ï¸', 'ðŸ˜‚', 'ðŸ˜®', 'ðŸ˜¢', 'ðŸ˜¡', 'ðŸŽ‰', 'ðŸ”¥', 'ðŸ‘€', 'ðŸ¤”'];

// Text formatting state
let isBoldActive = false;
let isItalicActive = false;

// Enhanced sticker system with categories
const stickerCategories = {
  'funny': [
    'https://cdn-icons-png.flaticon.com/512/742/742751.png',
    'https://cdn-icons-png.flaticon.com/512/742/742752.png',
    'https://cdn-icons-png.flaticon.com/512/742/742753.png',
    'https://cdn-icons-png.flaticon.com/512/742/742754.png'
  ],
  'reactions': [
    'https://cdn-icons-png.flaticon.com/512/742/742755.png',
    'https://cdn-icons-png.flaticon.com/512/742/742756.png',
    'https://cdn-icons-png.flaticon.com/512/742/742757.png',
    'https://cdn-icons-png.flaticon.com/512/742/742758.png'
  ],
  'animals': [
    'https://cdn-icons-png.flaticon.com/512/742/742759.png',
    'https://cdn-icons-png.flaticon.com/512/742/742760.png',
    'https://cdn-icons-png.flaticon.com/512/742/742761.png',
    'https://cdn-icons-png.flaticon.com/512/742/742762.png'
  ]
};

// WebRTC configuration
const rtcConfiguration = {
iceServers: [
{ urls: 'stun:stun.l.google.com:19302' },
{ urls: 'stun:stun1.l.google.com:19302' }
]
};

// Profile picture options - UPDATED WITH NEW IMAGES
const profilePictures = [
{ id: 1, name: "Cat", url: "https://images.unsplash.com/photo-1703248187251-c897f32fe4ec?ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&q=80&w=1035" },
{ id: 2, name: "Bear", url: "https://plus.unsplash.com/premium_photo-1661849977833-c18cd1c7e295?ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxzZWFyY2h8MXx8YmVhcnxlbnwwfHwwfHx8MA%3D%3D&auto=format&fit=crop&q=60&w=700" },
{ id: 3, name: "Rabbit", url: "https://images.unsplash.com/photo-1585110396000-c9ffd4e4b308?w=150&h=150&fit=crop&crop=center" },
{ id: 4, name: "Fox", url: "https://images.unsplash.com/photo-1561731216-c3a4d99437d5?w=150&h=150&fit=crop&crop=center" },
{ id: 5, name: "Owl", url: "https://images.unsplash.com/photo-1574085975024-eaa85ec28107?w=150&h=150&fit=crop&crop=center" },
{ id: 6, name: "Dog", url: "https://images.unsplash.com/photo-1518717758536-85ae29035b6d?w=150&h=150&fit=crop&crop=center" },
{ id: 7, name: "Lion", url: "https://images.unsplash.com/photo-1546182990-dffeafbe841d?w=150&h=150&fit=crop&crop=center" }
];

// Wallpaper options
const wallpapers = [
{
name: "Purple Gradient",
preview: "linear-gradient(135deg, #667eea, #764ba2)"
},
{
name: "Sunset",
preview: "linear-gradient(135deg, #f6d365, #fda085)"
},
{
name: "Ocean",
preview: "linear-gradient(135deg, #84fab0, #8fd3f4)"
},
{
name: "Pink Dream",
preview: "linear-gradient(135deg, #ff9a9e, #fad0c4)"
},
{
name: "Mint Fresh",
preview: "linear-gradient(135deg, #a8edea, #fed6e3)"
},
{
name: "Lavender",
preview: "linear-gradient(135deg, #d299c2, #fef9d7)"
},
{
name: "Dark Space",
preview: "linear-gradient(135deg, #2c3e50, #4ca1af)"
},
{
name: "Warm Fire",
preview: "linear-gradient(135deg, #ffecd2, #fcb69f)"
},
{
name: "Forest",
preview: "linear-gradient(135deg, #0ba360, #3cba92)"
},
{
name: "Berry",
preview: "linear-gradient(135deg, #ff9a9e, #fecfef)"
}
];

// ==================== FIXED LINK INSERTION FUNCTIONALITY ====================

// Insert link into message input - FIXED VERSION
function insertLink() {
  const url = linkUrlInput.value.trim();
  const displayText = linkDisplayInput.value.trim();

  if (!url) {
    showError('Please enter a URL');
    return;
  }

  // Validate URL format
  if (!isValidUrl(url)) {
    showError('Please enter a valid URL (starting with http:// or https://)');
    return;
  }

  // Create link markup - FIXED: Use proper Markdown-style links
  const linkMarkup = displayText ? `[${displayText}](${url})` : url;

  // Insert into message input
  const messageInput = document.getElementById('message-input');
  const start = messageInput.selectionStart;
  const end = messageInput.selectionEnd;
  
  if (start !== end) {
    // Replace selected text with link
    messageInput.value = messageInput.value.substring(0, start) + linkMarkup + messageInput.value.substring(end);
  } else {
    // Insert at cursor position
    if (messageInput.value) {
      messageInput.value += ' ' + linkMarkup;
    } else {
      messageInput.value = linkMarkup;
    }
  }

  // Close modal and focus input
  linkShareModal.style.display = 'none';
  messageInput.focus();
  
  // Set cursor position after the inserted link
  const newCursorPos = start + linkMarkup.length;
  messageInput.setSelectionRange(newCursorPos, newCursorPos);

  showSuccess('Link inserted into message!');
}

// ==================== FIXED TEXT FORMATTING FUNCTIONALITY ====================

// Toggle text formatting - FIXED: No extra stars
function toggleTextFormatting(type) {
  const input = document.getElementById('message-input');
  const start = input.selectionStart;
  const end = input.selectionEnd;
  const selectedText = input.value.substring(start, end);
  
  let formattedText = '';
  let newCursorPos = 0;

  switch(type) {
    case 'bold':
      if (selectedText) {
        // Check if already bold
        if (selectedText.startsWith('**') && selectedText.endsWith('**')) {
          // Remove bold formatting
          formattedText = selectedText.substring(2, selectedText.length - 2);
          newCursorPos = start + formattedText.length;
          isBoldActive = false;
        } else {
          // Add bold formatting
          formattedText = `**${selectedText}**`;
          newCursorPos = start + formattedText.length;
          isBoldActive = true;
        }
      } else {
        // No text selected, insert bold markers
        formattedText = '****';
        newCursorPos = start + 2;
        isBoldActive = true;
      }
      boldBtn.classList.toggle('active', isBoldActive);
      break;
    
    case 'italic':
      if (selectedText) {
        // Check if already italic
        if (selectedText.startsWith('*') && selectedText.endsWith('*') && 
            !selectedText.startsWith('**') && !selectedText.endsWith('**')) {
          // Remove italic formatting
          formattedText = selectedText.substring(1, selectedText.length - 1);
          newCursorPos = start + formattedText.length;
          isItalicActive = false;
        } else {
          // Add italic formatting
          formattedText = `*${selectedText}*`;
          newCursorPos = start + formattedText.length;
          isItalicActive = true;
        }
      } else {
        // No text selected, insert italic markers
        formattedText = '**';
        newCursorPos = start + 1;
        isItalicActive = true;
      }
      italicBtn.classList.toggle('active', isItalicActive);
      break;
  }

  // Replace the selected text with formatted text
  input.value = input.value.substring(0, start) + formattedText + input.value.substring(end);
  
  // Set cursor position
  input.focus();
  input.setSelectionRange(newCursorPos, newCursorPos);
  
  // NEW: Reset button states after a short delay if no text is selected
  setTimeout(() => {
    const newSelection = input.value.substring(input.selectionStart, input.selectionEnd);
    if (newSelection.length === 0) {
      isBoldActive = false;
      isItalicActive = false;
      boldBtn.classList.remove('active');
      italicBtn.classList.remove('active');
    }
  }, 100);
}

// ==================== FIXED TIME FORMATTING ====================

// Function to format time - FIXED: Properly handles dates before yesterday
function formatTime(timestamp) {
  const now = new Date();
  const messageDate = new Date(timestamp);
  const diffTime = now.getTime() - messageDate.getTime();
  const diffMinutes = Math.floor(diffTime / (1000 * 60));
  const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

  if (diffMinutes < 1) {
    return 'Now';
  } else if (diffMinutes < 60) {
    return `${diffMinutes} min${diffMinutes === 1 ? '' : 's'} ago`;
  }

  let hours = messageDate.getHours();
  const minutes = messageDate.getMinutes().toString().padStart(2, '0');
  const ampm = hours >= 12 ? 'PM' : 'AM';
  hours = hours % 12 || 12;
  const timeString = `${hours}:${minutes} ${ampm}`;

  // Check if it's today
  if (messageDate.toDateString() === now.toDateString()) {
    return timeString;
  }

  // Check if it's yesterday
  const yesterday = new Date(now);
  yesterday.setDate(yesterday.getDate() - 1);
  if (messageDate.toDateString() === yesterday.toDateString()) {
    return `Yesterday at ${timeString}`;
  }

  // Check if it's within the last week
  if (diffDays < 7) {
    const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    return `${dayNames[messageDate.getDay()]} at ${timeString}`;
  }

  // Check if it's the same year
  if (messageDate.getFullYear() === now.getFullYear()) {
    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    return `${monthNames[messageDate.getMonth()]} ${messageDate.getDate()} at ${timeString}`;
  }

  // Otherwise, return full date
  const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  return `${monthNames[messageDate.getMonth()]} ${messageDate.getDate()}, ${messageDate.getFullYear()} at ${timeString}`;
}

// ==================== FIXED MESSAGE ORDERING ====================

// Load messages using HTTP requests - FIXED: Ensures messages are in order
async function loadMessages() {
  try {
    console.log('ðŸ“¥ Loading messages from database...');

    // Try to load messages from database first
    let messages = await serverFetch(currentServer, 'messages?order=id.asc'); // Order by ID to ensure correct order

    console.log(`ðŸ“¨ Received ${messages?.length || 0} messages from database`);

    if (messages && messages.length > 0) {
      console.log(`ðŸ’¾ Loaded ${messages.length} messages from database`);
      allMessages = messages;

      // Update lastMessageId to the highest ID in the database
      lastMessageId = Math.max(...messages.map(msg => msg.id));
      console.log('ðŸ“Š Last message ID set to:', lastMessageId);

      // Clear messages and reset date tracking
      messagesDiv.innerHTML = '';
      lastDateSeparator = null;

      // Add all messages to current server storage
      messages.forEach(message => {
        addMessageToServer(currentServer, message);
      });

      // Re-render all messages IN ORDER
      for (const message of messages) {
        await renderMessage(
          message.text,
          message.user_id,
          message.user_name,
          message.created_at,
          message.id,
          message.edited_at,
          false,
          message
        );
      }

      // Add unread separator if needed
      addUnreadSeparatorIfNeeded();

      // Update online users based on recent activity
      updateOnlineUsers();

      showTemporaryStatus(`âœ… Loaded ${messages.length} messages`);
      isOnline = true;
    } else {
      console.log('ðŸ’­ No messages in database, starting fresh');
      allMessages = [];
      lastMessageId = 0;

      loadingDiv.textContent = "No messages yet. Start the conversation!";
      showTemporaryStatus("âœ… Connected! Ready to chat");
      isOnline = true;
    }

    statusDiv.className = 'status connected';

  } catch (error) {
    console.error('âŒ Error loading messages:', error);

    // If database fails, start with empty messages
    console.log('ðŸš« Database connection failed, starting with empty chat');
    allMessages = [];
    lastMessageId = 0;

    // Clear messages
    messagesDiv.innerHTML = '';
    lastDateSeparator = null;

    loadingDiv.textContent = "Welcome! Start the conversation";
    showTemporaryStatus('âš ï¸ Offline mode - messages saved locally only', false);
    isOnline = false;
  }
}

// ==================== FIXED MEDIA SHARING ====================

// Send GIF message - FIXED: Now properly shares with other users
async function sendGif(gifUrl) {
  const gifMessage = {
    type: 'gif',
    gifUrl: gifUrl,
    text: input.value.trim() || '',
    user_id: userId,
    user_name: userName,
    created_at: new Date().toISOString(),
    id: Date.now()
  };

  // Send based on current context
  if (currentServer === 'dms' && currentDM) {
    saveDMMessage(gifMessage, currentDM.id);
  } else {
    // Use server-specific storage
    addMessageToServer(currentServer, gifMessage);
    
    // Also send to the actual server database if configured
    try {
      await serverFetch(currentServer, 'messages', {
        method: 'POST',
        body: JSON.stringify({
          text: `[GIF] ${gifMessage.text || 'Sent a GIF'}`,
          user_id: userId,
          user_name: userName,
          created_at: new Date().toISOString(),
          gif_url: gifUrl // Store GIF URL for other users to see
        })
      });
    } catch (error) {
      console.warn(`Could not send GIF to ${currentServer} server database`);
    }
  }

  // Render the GIF message
  await renderMessage(
    gifMessage.text,
    gifMessage.user_id,
    gifMessage.user_name,
    gifMessage.created_at,
    gifMessage.id,
    null,
    null,
    gifMessage
  );

  // Reset and close
  input.value = '';
  gifStickerModal.style.display = 'none';
  showSuccess('GIF sent successfully!');
}

// Send file - FIXED: Now properly shares with other users
async function sendFile() {
  if (!currentFile) {
    showError('Please select a file to upload');
    return;
  }

  try {
    sendFileBtn.disabled = true;
    sendFileBtn.textContent = 'Uploading...';

    // In a real app, you would upload to a server
    // For this demo, we'll create a local URL
    const fileUrl = URL.createObjectURL(currentFile);

    // Create file message
    const fileMessage = {
      type: 'file',
      fileUrl: fileUrl,
      fileName: currentFile.name,
      fileSize: currentFile.size,
      fileType: currentFile.type,
      text: input.value.trim() || '',
      user_id: userId,
      user_name: userName,
      created_at: new Date().toISOString(),
      id: Date.now()
    };

  // Send based on current context
  if (currentServer === 'dms' && currentDM) {
    // Send DM file
    saveDMMessage(fileMessage, currentDM.id);
  } else {
    // Send server file
    addMessageToServer(currentServer, fileMessage);
    
    // Also send to the actual server database if configured
    try {
      await serverFetch(currentServer, 'messages', {
        method: 'POST',
        body: JSON.stringify({
          text: `[FILE] ${fileMessage.text || 'Sent a file'}`,
          user_id: userId,
          user_name: userName,
          created_at: new Date().toISOString(),
          file_url: fileUrl, // Store file URL for other users
          file_name: currentFile.name,
          file_type: currentFile.type
        })
      });
    } catch (error) {
      console.warn(`Could not send file to ${currentServer} server database`);
    }
  }

  // Render the file message
  await renderMessage(
    fileMessage.text,
    fileMessage.user_id,
    fileMessage.user_name,
    fileMessage.created_at,
    fileMessage.id,
    null,
    null,
    fileMessage
  );

  // Reset and close
  input.value = '';
  fileUploadModal.style.display = 'none';
  resetFileUpload();

  showSuccess('File sent successfully!');

  } catch (error) {
    console.error('âŒ Error sending file:', error);
    showError('Failed to send file. Please try again.');
  } finally {
    sendFileBtn.disabled = false;
    sendFileBtn.textContent = 'Send File';
  }
}

// ==================== INITIALIZATION FUNCTIONS ====================

// Initialize text formatting functionality
function initializeTextFormatting() {
  console.log('ðŸŽ¨ Initializing text formatting functionality...');

  // Set up bold button
  boldBtn.addEventListener('click', () => {
    toggleTextFormatting('bold');
  });

  // Set up italic button
  italicBtn.addEventListener('click', () => {
    toggleTextFormatting('italic');
  });

  // Set up keyboard shortcuts
  input.addEventListener('keydown', handleFormattingShortcuts);
}

// Initialize link sharing functionality
function initializeLinkSharing() {
  console.log('ðŸ”— Initializing link sharing functionality...');

  // Set up link share button
  linkShareBtn.addEventListener('click', () => {
    linkShareModal.style.display = 'flex';
    linkUrlInput.value = '';
    linkDisplayInput.value = '';
    linkPreview.classList.add('hidden');
  });

  // Set up link URL input change
  linkUrlInput.addEventListener('input', updateLinkPreview);
  linkDisplayInput.addEventListener('input', updateLinkPreview);

  // Set up link modal buttons
  cancelLinkBtn.addEventListener('click', () => {
    linkShareModal.style.display = 'none';
  });

  insertLinkBtn.addEventListener('click', insertLink);

  // Set up modal close
  linkShareModal.addEventListener('click', (e) => {
    if (e.target === linkShareModal) {
      linkShareModal.style.display = 'none';
    }
  });
}

// Initialize GIF and sticker functionality with Giphy integration
function initializeGifSticker() {
  console.log('ðŸŽ­ Initializing GIF & Sticker functionality with Giphy...');

  // Set up GIF/Sticker button
  gifStickerBtn.addEventListener('click', () => {
    gifStickerModal.style.display = 'flex';
    loadTrendingGifs();
    loadStickers();
  });

  // Set up tab switching
  gifStickerTabs.forEach(tab => {
    tab.addEventListener('click', () => {
      const tabName = tab.getAttribute('data-tab');
      switchGifStickerTab(tabName);
      
      if (tabName === 'gifs') {
        loadTrendingGifs();
      }
    });
  });

  // Set up GIF search
  let searchTimeout;
  
  gifSearchInput.addEventListener('input', (e) => {
    clearTimeout(searchTimeout);
    const query = e.target.value.trim();
    
    if (query.length === 0) {
      loadTrendingGifs();
    } else if (query.length > 2) {
      searchTimeout = setTimeout(() => {
        searchGifs(query);
      }, 500);
    }
  });

  // Set up modal close
  gifStickerModal.addEventListener('click', (e) => {
    if (e.target === gifStickerModal) {
      gifStickerModal.style.display = 'none';
    }
  });

  cancelGifStickerBtn.addEventListener('click', () => {
    gifStickerModal.style.display = 'none';
  });
}

// Initialize file upload functionality
function initializeFileUpload() {
  console.log('ðŸ“ Initializing file upload functionality...');

  // Set up file upload button
  fileUploadBtn.addEventListener('click', () => {
    fileUploadModal.style.display = 'flex';
    resetFileUpload();
  });

  // Set up file input change
  fileInput.addEventListener('change', handleFileSelect);

  // Set up drag and drop
  fileUploadArea.addEventListener('dragover', (e) => {
    e.preventDefault();
    fileUploadArea.classList.add('dragover');
  });

  fileUploadArea.addEventListener('dragleave', () => {
    fileUploadArea.classList.remove('dragover');
  });

  fileUploadArea.addEventListener('drop', (e) => {
    e.preventDefault();
    fileUploadArea.classList.remove('dragover');
    const files = e.dataTransfer.files;
    if (files.length > 0) {
      handleFile(files[0]);
    }
  });

  // Set up click to upload
  fileUploadArea.addEventListener('click', () => {
    fileInput.click();
  });

  // Set up upload buttons
  cancelUploadBtn.addEventListener('click', () => {
    fileUploadModal.style.display = 'none';
    resetFileUpload();
  });

  sendFileBtn.addEventListener('click', sendFile);

  // Set up modal close
  fileUploadModal.addEventListener('click', (e) => {
    if (e.target === fileUploadModal) {
      fileUploadModal.style.display = 'none';
      resetFileUpload();
    }
  });
}

// ==================== HELPER FUNCTIONS ====================

// Handle keyboard shortcuts for formatting
function handleFormattingShortcuts(e) {
  // Check for Cmd (Mac) or Ctrl (Windows/Linux) key
  const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
  const cmdKey = isMac ? e.metaKey : e.ctrlKey;

  if (cmdKey) {
    switch(e.key) {
      case 'b':
        e.preventDefault();
        toggleTextFormatting('bold');
        break;
      case 'i':
        e.preventDefault();
        toggleTextFormatting('italic');
        break;
    }
  }
}

// Update link preview
function updateLinkPreview() {
  const url = linkUrlInput.value.trim();
  const displayText = linkDisplayInput.value.trim();

  if (url) {
    linkPreview.classList.remove('hidden');
    const previewText = displayText || url;
    linkPreviewUrl.textContent = previewText;
  } else {
    linkPreview.classList.add('hidden');
  }
}

// Validate URL format
function isValidUrl(string) {
  try {
    new URL(string);
    return true;
  } catch (_) {
    return false;
  }
}

// Parse Markdown formatting in messages
function parseMarkdown(text) {
  // Parse bold (**text**)
  text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
  
  // Parse italic (*text*)
  text = text.replace(/\*(.*?)\*/g, '<em>$1</em>');
  
  return text;
}

// Parse and render links in messages - ENHANCED VERSION
function parseAndRenderLinks(text) {
  // Handle Markdown-style links [text](url)
  text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer" style="color: #5865f2; text-decoration: underline;">$1</a>');
  
  // Handle plain URLs
  const urlRegex = /(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/g;
  text = text.replace(urlRegex, '<a href="$1" target="_blank" rel="noopener noreferrer" style="color: #5865f2; text-decoration: underline;">$1</a>');
  
  return text;
}

// Load trending GIFs from Giphy
async function loadTrendingGifs() {
  if (!GIPHY_API_KEY || GIPHY_API_KEY === 'YOUR_GIPHY_API_KEY') {
    showGiphyApiWarning();
    return;
  }

  gifsGrid.innerHTML = '<div class="gif-loading"><span>Loading trending GIFs...</span></div>';

  try {
    const response = await fetch(`${GIPHY_BASE_URL}/trending?api_key=${GIPHY_API_KEY}&limit=20&rating=g`);
    const data = await response.json();
    
    displayGifs(data.data);
  } catch (error) {
    console.error('âŒ Error loading trending GIFs:', error);
    gifsGrid.innerHTML = '<div class="gif-loading"><span>Error loading GIFs</span></div>';
  }
}

// Search GIFs from Giphy
async function searchGifs(query) {
  if (!GIPHY_API_KEY || GIPHY_API_KEY === 'YOUR_GIPHY_API_KEY') {
    showGiphyApiWarning();
    return;
  }

  gifsGrid.innerHTML = '<div class="gif-loading"><span>Searching GIFs...</span></div>';

  try {
    const response = await fetch(`${GIPHY_BASE_URL}/search?api_key=${GIPHY_API_KEY}&q=${encodeURIComponent(query)}&limit=20&rating=g`);
    const data = await response.json();
    
    displayGifs(data.data);
  } catch (error) {
    console.error('âŒ Error searching GIFs:', error);
    gifsGrid.innerHTML = '<div class="gif-loading"><span>Error searching GIFs</span></div>';
  }
}

// Display GIFs in the grid
function displayGifs(gifs) {
  gifsGrid.innerHTML = '';

  if (!gifs || gifs.length === 0) {
    gifsGrid.innerHTML = '<div class="gif-loading"><span>No GIFs found</span></div>';
    return;
  }

  gifs.forEach(gif => {
    const gifItem = document.createElement('div');
    gifItem.classList.add('gif-sticker-item');

    const img = document.createElement('img');
    img.src = gif.images.fixed_height.url;
    img.alt = gif.title || 'GIF';
    img.loading = 'lazy';
    img.style.width = '100%';
    img.style.height = '100%';
    img.style.objectFit = 'cover';

    gifItem.appendChild(img);

    gifItem.addEventListener('click', () => {
      sendGif(gif.images.original.url);
    });

    gifsGrid.appendChild(gifItem);
  });
}

// Show warning about Giphy API key
function showGiphyApiWarning() {
  gifsGrid.innerHTML = `
    <div class="gif-loading" style="flex-direction: column; text-align: center;">
      <span style="margin-bottom: 10px;">Giphy API Key Required</span>
      <small style="font-size: 0.8rem; color: #666;">
        Get a free API key from <a href="https://developers.giphy.com/" target="_blank">developers.giphy.com</a>
        <br>and update the GIPHY_API_KEY variable
      </small>
    </div>
  `;
}

// Load stickers with categories
function loadStickers() {
  stickersGrid.innerHTML = '';

  Object.entries(stickerCategories).forEach(([category, stickers]) => {
    const categorySection = document.createElement('div');
    categorySection.classList.add('sticker-category');

    const categoryTitle = document.createElement('h4');
    categoryTitle.textContent = category.charAt(0).toUpperCase() + category.slice(1);
    categorySection.appendChild(categoryTitle);

    const categoryGrid = document.createElement('div');
    categoryGrid.classList.add('gif-sticker-grid');
    categoryGrid.style.gridTemplateColumns = 'repeat(4, 1fr)';

    stickers.forEach((sticker, index) => {
      const stickerItem = document.createElement('div');
      stickerItem.classList.add('gif-sticker-item');

      const img = document.createElement('img');
      img.src = sticker;
      img.alt = `${category} sticker ${index + 1}`;
      img.loading = 'lazy';
      img.style.width = '100%';
      img.style.height = '100%';
      img.style.objectFit = 'contain';

      stickerItem.appendChild(img);

      stickerItem.addEventListener('click', () => {
        sendSticker(sticker);
      });

      categoryGrid.appendChild(stickerItem);
    });

    categorySection.appendChild(categoryGrid);
    stickersGrid.appendChild(categorySection);
  });
}

// Switch GIF/Sticker tab
function switchGifStickerTab(tabName) {
  // Update active tab
  gifStickerTabs.forEach(tab => {
    if (tab.getAttribute('data-tab') === tabName) {
      tab.classList.add('active');
    } else {
      tab.classList.remove('active');
    }
  });

  // Show/hide content
  document.querySelectorAll('.gif-sticker-tab-content').forEach(content => {
    if (content.id === `${tabName}-tab`) {
      content.classList.remove('hidden');
    } else {
      content.classList.add('hidden');
    }
  });
}

// Send sticker message
async function sendSticker(stickerUrl) {
  const stickerMessage = {
    type: 'sticker',
    stickerUrl: stickerUrl,
    text: input.value.trim() || '',
    user_id: userId,
    user_name: userName,
    created_at: new Date().toISOString(),
    id: Date.now()
  };

  // Send based on current context
  if (currentServer === 'dms' && currentDM) {
    saveDMMessage(stickerMessage, currentDM.id);
  } else {
    // Use server-specific storage
    addMessageToServer(currentServer, stickerMessage);
    
    // Also send to the actual server database if configured
    try {
      await serverFetch(currentServer, 'messages', {
        method: 'POST',
        body: JSON.stringify({
          text: `[Sticker] ${stickerMessage.text || 'Sent a sticker'}`,
          user_id: userId,
          user_name: userName,
          created_at: new Date().toISOString(),
          sticker_url: stickerUrl // Store sticker URL for other users
        })
      });
    } catch (error) {
      console.warn(`Could not send sticker to ${currentServer} server database`);
    }
  }

  // Render the sticker message
  await renderMessage(
    stickerMessage.text,
    stickerMessage.user_id,
    stickerMessage.user_name,
    stickerMessage.created_at,
    stickerMessage.id,
    null,
    null,
    stickerMessage
  );

  // Reset and close
  input.value = '';
  gifStickerModal.style.display = 'none';
  showSuccess('Sticker sent successfully!');
}

// Handle file selection
function handleFileSelect(e) {
  const file = e.target.files[0];
  if (file) {
    handleFile(file);
  }
}

// Handle file
function handleFile(file) {
  // Check file size (max 10MB)
  if (file.size > 10 * 1024 * 1024) {
    showError('File size must be less than 10MB');
    return;
  }

  currentFile = file;
  showFilePreview(file);
}

// Show file preview
function showFilePreview(file) {
  filePreview.innerHTML = '';

  const fileType = file.type.split('/')[0];
  const fileName = file.name;
  const fileSize = formatFileSize(file.size);

  if (fileType === 'image') {
    const img = document.createElement('img');
    img.src = URL.createObjectURL(file);
    filePreview.appendChild(img);
  } else if (fileType === 'video') {
    const video = document.createElement('video');
    video.src = URL.createObjectURL(file);
    video.controls = true;
    filePreview.appendChild(video);
  } else {
    const fileElement = document.createElement('div');
    fileElement.classList.add('attachment-file');

    const icon = document.createElement('span');
    icon.classList.add('material-icons', 'file-icon');
    icon.textContent = 'insert_drive_file';

    const info = document.createElement('div');
    info.classList.add('file-info');

    const name = document.createElement('div');
    name.classList.add('file-name');
    name.textContent = fileName;

    const size = document.createElement('div');
    size.classList.add('file-size');
    size.textContent = fileSize;

    info.appendChild(name);
    info.appendChild(size);
    fileElement.appendChild(icon);
    fileElement.appendChild(info);

    filePreview.appendChild(fileElement);
  }
}

// Format file size
function formatFileSize(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

// Reset file upload
function resetFileUpload() {
  currentFile = null;
  fileInput.value = '';
  filePreview.innerHTML = '';
  fileUploadArea.classList.remove('dragover');
}

// Download file
function downloadFile(url, filename) {
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}

// ==================== BASIC CHAT FUNCTIONALITY ====================

// Initialize user
function initializeUser() {
  userName = localStorage.getItem('chatUserName');
  userId = localStorage.getItem('chatUserId');

  if (!userName) {
    let name = prompt("Enter your name:") || "Anonymous";
    name = name.trim() || "Anonymous";
    localStorage.setItem('chatUserName', name);
    userName = name;
  }

  if (!userId) {
    userId = 'user-' + Date.now() + '-' + Math.random().toString(36).substring(2, 9);
    localStorage.setItem('chatUserId', userId);
  }

  userDisplay.textContent = `You: ${userName}`;
  console.log(`ðŸ‘¤ User initialized: ${userName} (${userId})`);
}

// Initialize sidebar functionality
function initializeSidebar() {
  console.log('ðŸ”„ Initializing sidebar...');

  // Set up server icon click handlers
  serverIcons.forEach(icon => {
    icon.addEventListener('click', function() {
      const server = this.getAttribute('data-server');
      switchServer(server);
    });
  });

  // Set up user section
  updateUserSection();

  // Update DM list periodically to show ALL users with online/offline status
  updateDMList();
  setInterval(updateDMList, 5000); // Update every 5 seconds
}

// Select a DM conversation
function selectDM(user) {
  console.log(`ðŸ’¬ Selecting DM with ${user.name}`);

  // Clear active DM
  clearActiveDM();

  // Set new active DM
  currentDM = user;

  // Update UI to show active DM
  const dmItems = document.querySelectorAll('.dm-item');
  dmItems.forEach(item => {
    if (item.getAttribute('data-user-id') === user.id) {
      item.classList.add('active');
    }
  });

  // Update header
  const header = document.querySelector('.header div');
  header.textContent = user.name;

  // Enable message input for DM
  input.disabled = false;
  input.placeholder = `Message ${user.name}...`;
  sendButton.disabled = false;

  // Load DM messages
  loadDMMessages(user.id);

  showSuccess(`Started DM with ${user.name}`);
}

// Load DM messages for a specific user
async function loadDMMessages(targetUserId) {
  try {
    // Load from database first
    const dbMessages = await loadDMsFromDatabase(userId, targetUserId);
    
    // Clear current messages
    messagesDiv.innerHTML = '';
    lastDateSeparator = null;

    if (dbMessages.length === 0) {
      const welcomeMessage = document.createElement('div');
      welcomeMessage.style.textAlign = 'center';
      welcomeMessage.style.padding = '20px';
      welcomeMessage.style.color = '#666';
      welcomeMessage.textContent = `Start a conversation with ${currentDM.name}`;
      messagesDiv.appendChild(welcomeMessage);
    } else {
      // Render DM messages from database
      for (const message of dbMessages) {
        const isSelf = message.sender_id === userId;
        await renderMessage(
          message.message_text,
          message.sender_id,
          isSelf ? userName : currentDM.name,
          message.created_at,
          message.id,
          message.edited_at,
          false,
          {
            type: message.message_type,
            ...message
          }
        );
      }
    }
  } catch (error) {
    console.error('Error loading DM messages:', error);
    showError('Failed to load DM messages');
  }
}

// Save a DM message
function saveDMMessage(message, targetUserId) {
  const dmKey = `dm_${userId}_${targetUserId}`;

  if (!dmMessages[targetUserId]) {
    dmMessages[targetUserId] = [];
  }

  dmMessages[targetUserId].push(message);
  localStorage.setItem(dmKey, JSON.stringify(dmMessages[targetUserId]));
}

// Clear active DM selection
function clearActiveDM() {
  const dmItems = document.querySelectorAll('.dm-item');
  dmItems.forEach(item => {
    item.classList.remove('active');
  });

  currentDM = null;
}

// Update user section in sidebar
function updateUserSection() {
  if (userName) {
    userSidebarName.textContent = userName;
    userSidebarTag.textContent = `#${userId.slice(-4)}`;

    // Update avatar if available
    if (userProfilePicture) {
      userSidebarAvatar.innerHTML = '';
      const img = document.createElement('img');
      img.src = userProfilePicture;
      img.alt = `${userName}'s avatar`;
      userSidebarAvatar.appendChild(img);
    }
  }
}

// Get unique users from messages
function getUniqueUsersFromMessages() {
  const usersMap = new Map();

  // Add users from messages
  allMessages.forEach(message => {
    if (!usersMap.has(message.user_id)) {
      usersMap.set(message.user_id, {
        id: message.user_id,
        name: message.user_name,
        avatar: generateAvatar(message.user_name)
      });
    }
  });

  // Add current user
  usersMap.set(userId, {
    id: userId,
    name: userName,
    avatar: userProfilePicture
  });

  return Array.from(usersMap.values());
}

// Generate animal avatar based on user name
function generateAvatar(name) {
  const animals = ['cat', 'dog', 'rabbit', 'fox', 'owl', 'bear', 'lion'];
  const animalIndex = name.split('').reduce((a, b) => a + b.charCodeAt(0), 0) % animals.length;
  const animal = animals[animalIndex];

  // Map animal names to specific image URLs
  const imageMap = {
    'cat': 'https://images.unsplash.com/photo-1703248187251-c897f32fe4ec?ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&q=80&w=1035',
    'dog': 'https://images.unsplash.com/photo-1518717758536-85ae29035b6d?w=150&h=150&fit=crop&crop=center',
    'rabbit': 'https://images.unsplash.com/photo-1585110396000-c9ffd4e4b308?w=150&h=150&fit=crop&crop=center',
    'fox': 'https://images.unsplash.com/photo-1561731216-c3a4d99437d5?w=150&h=150&fit=crop&crop=center',
    'owl': 'https://images.unsplash.com/photo-1574085975024-eaa85ec28107?w=150&h=150&fit=crop&crop=center',
    'bear': 'https://plus.unsplash.com/premium_photo-1661849977833-c18cd1c7e295?ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxzZWFyY2h8MXx8YmVhcnxlbnwwfHwwfHx8MA%3D%3D&auto=format&fit=crop&q=60&w=700',
    'lion': 'https://images.unsplash.com/photo-1546182990-dffeafbe841d?w=150&h=150&fit=crop&crop=center'
  };

  return imageMap[animal] || profilePictures[0].url;
}

// Initialize profile picture functionality
function initializeProfilePictures() {
  console.log('ðŸ‘¤ Initializing profile picture functionality...');

  // Load saved profile picture
  userProfilePicture = localStorage.getItem('userProfilePicture') || profilePictures[0].url;

  // Populate profile picture options
  profilePictures.forEach(pic => {
    const pictureContainer = document.createElement("div");
    pictureContainer.classList.add("profile-picture-grid");

    const div = document.createElement("div");
    div.classList.add("profile-picture-option");
    div.style.backgroundImage = `url(${pic.url})`;
    div.setAttribute('data-picture-url', pic.url);

    const label = document.createElement("div");
    label.classList.add("profile-picture-label");
    label.textContent = pic.name;

    div.addEventListener("click", () => {
      userProfilePicture = pic.url;
      localStorage.setItem('userProfilePicture', pic.url);
      profilePictureModal.style.display = "none";
      showSuccess(`Profile picture changed to ${pic.name}!`);

      // Update all messages with new profile picture
      updateAllMessagesWithProfilePicture();
      // Update sidebar avatar
      updateUserSection();
    });

    pictureContainer.appendChild(div);
    pictureContainer.appendChild(label);
    profilePictureOptions.appendChild(pictureContainer);
  });

  // Set up profile picture button
  profilePictureBtn.addEventListener("click", () => {
    profilePictureModal.style.display = "flex";
  });

  profilePictureModal.addEventListener("click", (e) => {
    if (e.target === profilePictureModal) {
      profilePictureModal.style.display = "none";
    }
  });
}

// Update all messages with current profile picture
function updateAllMessagesWithProfilePicture() {
  const messageContainers = messagesDiv.querySelectorAll('.message-container.self');
  messageContainers.forEach(container => {
    const avatar = container.querySelector('.message-avatar');
    if (avatar) {
      avatar.src = userProfilePicture;
    }
  });
}

// Initialize audio call functionality
function initializeAudioCall() {
  console.log('ðŸ“ž Initializing audio call functionality...');

  // Set up event listeners for audio call buttons
  audioCallBtn.addEventListener('click', showCallUserSelection);
  endCallBtn.addEventListener('click', endAudioCall);
  acceptCallBtn.addEventListener('click', acceptIncomingCall);
  rejectCallBtn.addEventListener('click', rejectIncomingCall);
  cancelCallBtn.addEventListener('click', () => {
    callUserModal.style.display = 'none';
  });

  // Set up microphone permission buttons
  allowMicrophoneBtn.addEventListener('click', requestMicrophonePermission);
  denyMicrophoneBtn.addEventListener('click', () => {
    microphonePermissionModal.style.display = 'none';
    showError('Microphone access is required for audio calls.');
  });

  // Set up clear messages button
  clearMessagesBtn.addEventListener('click', clearAllMessages);

  // Set up typing indicators
  input.addEventListener('input', sendTypingIndicator);
}

// Show call user selection modal
function showCallUserSelection() {
  if (isInCall) {
    showError('You are already in a call');
    return;
  }

  // Get unique users from messages
  const users = getUniqueUsersFromMessages();

  // Populate the call user list
  callUserList.innerHTML = '';

  if (users.length === 0) {
    const noUsers = document.createElement('div');
    noUsers.textContent = 'No other users in the chat yet';
    noUsers.style.textAlign = 'center';
    noUsers.style.padding = '20px';
    noUsers.style.color = '#666';
    callUserList.appendChild(noUsers);
  } else {
    users.forEach(user => {
      if (user.id !== userId) { // Don't show yourself
        const userOption = document.createElement('div');
        userOption.classList.add('call-user-option');

        const avatar = document.createElement('img');
        avatar.classList.add('call-user-avatar');
        avatar.src = user.avatar || generateAvatar(user.name);

        const userInfo = document.createElement('div');
        userInfo.style.flex = '1';

        const name = document.createElement('div');
        name.classList.add('call-user-name');
        name.textContent = user.name;

        const status = document.createElement('div');
        status.classList.add('call-user-status');

        // Only show online if user is actually online
        if (onlineUsers.has(user.id)) {
          status.textContent = 'Online';
          status.classList.remove('offline');
        } else {
          status.textContent = 'Offline';
          status.classList.add('offline');
        }

        userInfo.appendChild(name);
        userInfo.appendChild(status);

        userOption.appendChild(avatar);
        userOption.appendChild(userInfo);

        userOption.addEventListener('click', () => {
          // Check if user is online before allowing call
          if (!onlineUsers.has(user.id)) {
            showError(`${user.name} is currently offline and cannot receive calls.`);
            return;
          }

          callTargetUserId = user.id;
          callTargetUserName = user.name;
          callTargetUserAvatar = user.avatar;
          callUserModal.style.display = 'none';
          startAudioCall(user.id, user.name, user.avatar);
        });

        callUserList.appendChild(userOption);
      }
    });
  }

  callUserModal.style.display = 'flex';
}

// Clear all messages function
async function clearAllMessages() {
  if (!confirm('Are you sure you want to delete ALL messages from everyone? This action cannot be undone.')) return;

  try {
    console.log('ðŸ—‘ï¸ Clearing all messages...');

    // Get all message IDs first
    const messages = await serverFetch(currentServer, 'messages?select=id');

    if (messages && messages.length > 0) {
      // Delete messages one by one to avoid any constraints
      for (const message of messages) {
        await serverFetch(currentServer, `messages?id=eq.${message.id}`, {
          method: 'DELETE'
        });
      }
    }

    // Clear local state
    allMessages = [];
    messagesDiv.innerHTML = '';
    lastMessageId = 0;
    lastDateSeparator = null;
    lastReadMessageId = 0;
    localStorage.setItem('lastReadMessageId', 0);

    // Clear all server storage
    Object.keys(serverMessages).forEach(server => {
      serverMessages[server] = [];
      saveServerMessages(server, []);
    });

    // Clear reactions
    messageReactions = {};
    saveMessageReactions();

    // Show empty state
    const loadingDiv = document.getElementById('loading');
    if (loadingDiv) {
      loadingDiv.textContent = "No messages yet. Start the conversation!";
      loadingDiv.style.display = 'block';
    }

    showTemporaryStatus('âœ… All messages cleared!');
    showSuccess('All messages cleared successfully! Everyone\'s chat is now empty.');
  } catch (error) {
    console.error('Error clearing messages:', error);
    showError('Failed to clear messages. Please try again.');
  }
}

// ==================== BASIC CHAT FUNCTIONS ====================

// Send encrypted message
async function sendMessage(text) {
  try {
    sendButton.disabled = true;
    sendButton.textContent = 'Sending...';

    // Clear typing indicator when sending
    typingUsers.delete(userName);
    updateTypingIndicator();

    // If we're editing a message, update it instead of sending a new one
    if (editingMessageId) {
      sendButton.textContent = 'Updating...';
      await updateMessage(editingMessageId, text);
      sendButton.disabled = false;
      return;
    }

    // Check if we're in a DM
    if (currentServer === 'dms' && currentDM) {
      // Send DM message
      await sendDMMessage(text);
    } else {
      // Send regular chat message
      await sendChatMessage(text);
    }

  } catch (error) {
    console.error('âŒ Error sending message:', error);
    showError('Failed to send message. Please try again.');
  } finally {
    sendButton.disabled = false;
    sendButton.textContent = 'Send';
  }
}

// Send regular chat message
async function sendChatMessage(text) {
  // For demo purposes, we'll just use plain text
  // In a real app, you would encrypt the message
  const newMessage = {
    text: text,
    user_id: userId,
    user_name: userName,
    created_at: new Date().toISOString()
  };

  console.log(`ðŸ“¤ Sending message to ${currentServer} server:`, newMessage);

  let sentMessage;

  try {
    // Try to send to the server-specific database
    const result = await serverFetch(currentServer, 'messages', {
      method: 'POST',
      body: JSON.stringify(newMessage)
    });

    if (result) {
      // Handle different response formats from Supabase
      if (Array.isArray(result) && result.length > 0) {
        sentMessage = result[0];
      } else if (result.id) {
        sentMessage = result;
      }
    }
  } catch (error) {
    console.warn(`âš ï¸ Could not send to ${currentServer} server database, using local storage`);
  }

  // If database send failed or we're using local storage, create local message
  if (!sentMessage) {
    sentMessage = {
      ...newMessage,
      id: Date.now() // Temporary local ID
    };
    console.warn('âš ï¸ Using local ID for message:', sentMessage.id);
  }

  console.log('âœ… Message saved with ID:', sentMessage.id);

  // Add to local state immediately
  allMessages.push(sentMessage);

  // Add to server storage
  addMessageToServer(currentServer, sentMessage);

  // Update lastMessageId to track the newest message
  if (sentMessage.id > lastMessageId) {
    lastMessageId = sentMessage.id;
  }

  // Render the message
  await renderMessage(
    sentMessage.text,
    userId,
    userName,
    sentMessage.created_at,
    sentMessage.id
  );

  input.value = '';
  console.log(`ðŸ’¬ Message sent to ${currentServer} server successfully`);
  showSuccess('Message sent!');
  return sentMessage;
}

// Server-specific fetch function
async function serverFetch(server, endpoint, options = {}) {
  const config = serverConfigs[server] || serverConfigs['home'];
  
  try {
    console.log(`ðŸ“¡ ${server.toUpperCase()} Server Request: ${endpoint}`, options.method || 'GET');

    const response = await fetch(`${config.url}/rest/v1/${endpoint}`, {
      headers: {
        'apikey': config.key,
        'Authorization': `Bearer ${config.key}`,
        'Content-Type': 'application/json',
        'Prefer': 'return=representation'
      },
      ...options
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error(`âŒ ${server.toUpperCase()} Server Error:`, {
        status: response.status,
        statusText: response.statusText,
        endpoint: endpoint,
        error: errorText
      });

      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const contentLength = response.headers.get('content-length');
    if (contentLength === '0' || response.status === 204) {
      console.log(`âœ… ${server.toUpperCase()} Empty response (success)`);
      return null;
    }

    const data = await response.json();
    console.log(`âœ… ${server.toUpperCase()} Server Response:`, data);
    return data;

  } catch (error) {
    console.error(`âŒ ${server.toUpperCase()} Server Fetch error:`, error);
    
    // If this is not the home server and it fails, show message about creating new Supabase
    if (server !== 'home') {
      console.warn(`âš ï¸ Server "${server}" not configured. You need to create a new Supabase project for this server.`);
      showError(`Server "${server}" is not configured. You need to create a separate Supabase project for this server.`);
    }
    
    throw error;
  }
}

// Save server messages
function saveServerMessages(server, messages) {
  serverMessages[server] = messages;
  localStorage.setItem(`serverMessages_${server}`, JSON.stringify(messages));
  console.log(`ðŸ’¾ Saved ${messages.length} messages for server: ${server}`);
}

// Load server messages
function loadServerMessages(server) {
  const saved = localStorage.getItem(`serverMessages_${server}`);
  if (saved) {
    try {
      serverMessages[server] = JSON.parse(saved);
      console.log(`ðŸ“‚ Loaded ${serverMessages[server].length} messages for server: ${server}`);
    } catch (error) {
      console.error(`âŒ Error loading messages for server ${server}:`, error);
      serverMessages[server] = [];
    }
  } else {
    serverMessages[server] = [];
    console.log(`ðŸ†• No saved messages found for server: ${server}, creating new array`);
  }
  return serverMessages[server];
}

// Add message to server storage
function addMessageToServer(server, message) {
  if (!serverMessages[server]) {
    serverMessages[server] = [];
  }
  serverMessages[server].push(message);
  saveServerMessages(server, serverMessages[server]);
  console.log(`âž• Added message to server ${server}, total messages: ${serverMessages[server].length}`);
}

// Switch between servers
function switchServer(server) {
  console.log(`ðŸ”„ Switching to server: ${server}`);
  
  // Update active server icon
  serverIcons.forEach(icon => {
    if (icon.getAttribute('data-server') === server) {
      icon.classList.add('active');
    } else {
      icon.classList.remove('active');
    }
  });
  
  // Update current server
  currentServer = server;
  
  // Clear current DM if switching away from DMs
  if (server !== 'dms') {
    currentDM = null;
    clearActiveDM();
  }
  
  // Update UI based on server
  if (server === 'dms') {
    showDMListView();
  } else {
    // Load messages for the selected server
    loadServerMessages(server);
    renderServerMessages(server);
    
    // Enable message input for server chat
    input.disabled = false;
    input.placeholder = 'Type your encrypted message...';
    sendButton.disabled = false;
    
    // Update header
    const header = document.querySelector('.header div');
    header.innerHTML = `Super Chat ðŸ”’`;
  }
  
  showSuccess(`Switched to ${server === 'dms' ? 'Direct Messages' : server} server`);
}

// Render messages for a specific server
function renderServerMessages(server) {
  const messages = serverMessages[server] || [];
  messagesDiv.innerHTML = '';
  lastDateSeparator = null;

  if (messages.length === 0) {
    const welcomeMessage = document.createElement('div');
    welcomeMessage.style.textAlign = 'center';
    welcomeMessage.style.padding = '20px';
    welcomeMessage.style.color = '#666';
    welcomeMessage.textContent = `Welcome to ${server} server! Start the conversation.`;
    messagesDiv.appendChild(welcomeMessage);
  } else {
    console.log(`ðŸŽ¨ Rendering ${messages.length} messages for server: ${server}`);
    // Render all messages for this server
    messages.forEach(message => {
      renderMessage(
        message.text,
        message.user_id,
        message.user_name,
        message.created_at,
        message.id,
        message.edited_at,
        false,
        message
      );
    });
  }

  // Scroll to bottom after rendering all messages
  scrollToBottom();
}

// Show DM list view (when DM server is selected)
function showDMListView() {
  messagesDiv.innerHTML = '';
  const welcomeMessage = document.createElement('div');
  welcomeMessage.style.textAlign = 'center';
  welcomeMessage.style.padding = '20px';
  welcomeMessage.style.color = '#666';
  welcomeMessage.textContent = 'Select a user from the DM list to start a conversation';
  messagesDiv.appendChild(welcomeMessage);

  // Disable message input in DM list view
  input.disabled = true;
  input.placeholder = 'Select a user to start messaging...';
  sendButton.disabled = true;
}

// Add date separator if needed
function addDateSeparatorIfNeeded(timestamp) {
  const messageDate = new Date(timestamp).toDateString();

  // If this is the first message or a new day, add a separator
  if (!lastDateSeparator || lastDateSeparator !== messageDate) {
    lastDateSeparator = messageDate;

    const separator = document.createElement('div');
    separator.classList.add('date-separator');

    const label = document.createElement('div');
    label.classList.add('date-label');
    label.textContent = formatDateForSeparator(timestamp);

    separator.appendChild(label);
    messagesDiv.appendChild(separator);
  }
}

// Format date for separator
function formatDateForSeparator(dateString) {
  const date = new Date(dateString);
  const today = new Date();
  const yesterday = new Date(today);
  yesterday.setDate(yesterday.getDate() - 1);

  // Check if it's today
  if (date.toDateString() === today.toDateString()) {
    return "Today";
  }

  // Check if it's yesterday
  if (date.toDateString() === yesterday.toDateString()) {
    return "Yesterday";
  }

  // Check if it's within the last week
  const daysDiff = Math.floor((today - date) / (1000 * 60 * 60 * 24));
  if (daysDiff < 7) {
    const dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    return dayNames[date.getDay()];
  }

  // Otherwise, return the full date
  const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  return `${monthNames[date.getMonth()]} ${date.getDate()}`;
}

// Add unread separator if needed
function addUnreadSeparatorIfNeeded() {
  // Check if we have unread messages
  const unreadMessages = allMessages.filter(msg => msg.id > lastReadMessageId && msg.user_id !== userId);

  if (unreadMessages.length > 0) {
    // Find the first unread message
    const firstUnreadMessage = unreadMessages[0];

    // Check if unread separator already exists
    const existingUnreadSeparator = document.querySelector('.unread-separator');
    if (existingUnreadSeparator) {
      existingUnreadSeparator.remove();
    }

    // Find the message element for the first unread message
    const firstUnreadElement = document.querySelector(`[data-message-id="${firstUnreadMessage.id}"]`);

    if (firstUnreadElement) {
      const separator = document.createElement('div');
      separator.classList.add('unread-separator');

      const label = document.createElement('div');
      label.classList.add('unread-label');
      label.textContent = 'Unread';

      separator.appendChild(label);

      // Insert the separator before the first unread message
      firstUnreadElement.parentNode.insertBefore(separator, firstUnreadElement);
    }
  } else {
    // Remove unread separator if no unread messages
    const existingUnreadSeparator = document.querySelector('.unread-separator');
    if (existingUnreadSeparator) {
      existingUnreadSeparator.remove();
    }
  }
}

// Update online users based on recent activity
function updateOnlineUsers() {
  // Clear current online users
  onlineUsers.clear();

  // Add current user
  onlineUsers.add(userId);

  // Add users who have sent messages in the last 5 minutes
  const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);

  allMessages.forEach(message => {
    const messageTime = new Date(message.created_at);
    if (messageTime > fiveMinutesAgo) {
      onlineUsers.add(message.user_id);
    }
  });
}

// Start polling for new messages
function startPolling() {
  pollInterval = setInterval(checkNewMessages, 2000);
}

// Show temporary status message
function showTemporaryStatus(message, isSuccess = true) {
  if (statusTimeout) {
    clearTimeout(statusTimeout);
  }

  statusDiv.textContent = message;
  statusDiv.className = isSuccess ? 'status connected' : 'status disconnected';
  statusDiv.style.display = 'flex';

  // Hide after 3 seconds
  statusTimeout = setTimeout(() => {
    statusDiv.style.display = 'none';
  }, 3000);
}

// Update typing indicator display
function updateTypingIndicator() {
  if (typingUsers.size === 0) {
    typingIndicator.style.display = 'none';
    return;
  }

  const usersArray = Array.from(typingUsers);

  if (usersArray.length === 1) {
    typingText.textContent = `${usersArray[0]} is typing`;
  } else if (usersArray.length === 2) {
    typingText.textContent = `${usersArray[0]} and ${usersArray[1]} are typing`;
  } else {
    typingText.textContent = `${usersArray.length} people are typing`;
  }

  typingIndicator.style.display = 'flex';
}

// Clear typing indicator after 3 seconds
function clearTypingIndicator() {
  if (typingTimeout) {
    clearTimeout(typingTimeout);
  }
  typingTimeout = setTimeout(() => {
    typingUsers.clear();
    updateTypingIndicator();
  }, 3000);
}

// Send typing indicator
function sendTypingIndicator() {
  const now = Date.now();
  // Only send typing indicator every 1 second to avoid spam
  if (now - lastTypingTime > 1000) {
    lastTypingTime = now;

    // Add current user to typing users
    typingUsers.add(userName);
    updateTypingIndicator();
    clearTypingIndicator();
  }
}

// Mark messages as read when scrolled into view
function setupMessageReadTracking() {
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const messageId = parseInt(entry.target.getAttribute('data-message-id'));
        if (messageId > lastReadMessageId) {
          lastReadMessageId = messageId;
          localStorage.setItem('lastReadMessageId', lastReadMessageId);
          addUnreadSeparatorIfNeeded();
        }
      }
    });
  }, { threshold: 0.5 });

  // Observe all message containers
  document.querySelectorAll('.message-container').forEach(container => {
    observer.observe(container);
  });
}

// Check for new messages
async function checkNewMessages() {
  if (!isOnline) return;

  try {
    // Use server-specific fetch for the current server
    const messages = await serverFetch(currentServer, `messages?id=gt.${lastMessageId}&order=id.asc`);

    if (messages && messages.length > 0) {
      console.log(`ðŸ†• Found ${messages.length} new messages in ${currentServer} server`);

      // Add new messages to local state
      for (const message of messages) {
        // Check if we already have this message
        if (!allMessages.some(msg => msg.id === message.id)) {
          allMessages.push(message);

          // Add to server storage
          addMessageToServer(currentServer, message);

          // Render the new message
          await renderMessage(
            message.text,
            message.user_id,
            message.user_name,
            message.created_at,
            message.id,
            message.edited_at,
            true,
            message
          );

          // Update lastMessageId
          if (message.id > lastMessageId) {
            lastMessageId = message.id;
          }
        }
      }

      // Add unread separator if needed
      addUnreadSeparatorIfNeeded();

      if (messages.length > 0) {
        console.log(`âœ… New messages loaded from ${currentServer} server`);
      }
    }
  } catch (error) {
    console.log(`Polling error for ${currentServer} server:`, error);
    isOnline = false;
    showTemporaryStatus(`âŒ ${currentServer} server offline - retrying...`, false);
  }
}

// Scroll to bottom
function scrollToBottom() {
  setTimeout(() => {
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
    // Mark all messages as read when scrolling to bottom
    if (allMessages.length > 0) {
      const latestMessageId = Math.max(...allMessages.map(msg => msg.id));
      if (latestMessageId > lastReadMessageId) {
        lastReadMessageId = latestMessageId;
        localStorage.setItem('lastReadMessageId', lastReadMessageId);
        addUnreadSeparatorIfNeeded();
      }
    }
  }, 100);
}

// Show error message
function showError(message) {
  errorMessage.textContent = message;
  errorMessage.style.display = 'block';
  successMessage.style.display = 'none';
  setTimeout(() => {
    errorMessage.style.display = 'none';
  }, 5000);
}

// Show success message
function showSuccess(message) {
  successMessage.textContent = message;
  successMessage.style.display = 'block';
  errorMessage.style.display = 'none';
  setTimeout(() => {
    successMessage.style.display = 'none';
  }, 3000);
}

// Apply wallpaper
function applyWallpaper(value) {
  document.body.style.background = '';
  document.body.style.backgroundImage = '';
  document.body.style.backgroundColor = '';

  if (value.startsWith('linear-gradient')) {
    document.body.style.background = value;
  } else {
    document.body.style.backgroundImage = value;
  }

  document.body.style.backgroundSize = 'cover';
  document.body.style.backgroundPosition = 'center';
  document.body.style.backgroundAttachment = 'fixed';
  localStorage.setItem("chatWallpaper", value);
}

// Initialize emoji picker
function initializeEmojiPicker() {
  console.log('ðŸŽ­ Initializing emoji picker...');
  emojiPickerGrid.innerHTML = '';

  // Populate emoji picker with available emojis
  availableEmojis.forEach(emoji => {
    const emojiOption = document.createElement('div');
    emojiOption.classList.add('emoji-option');
    emojiOption.textContent = emoji;
    emojiOption.title = emoji;
    emojiOption.addEventListener('click', () => {
      addReactionToMessage(currentReactingMessageId, emoji);
      emojiPickerModal.style.display = 'none';
    });
    emojiPickerGrid.appendChild(emojiOption);
  });

  // Set up emoji picker event listeners
  emojiPickerModal.addEventListener('click', (e) => {
    if (e.target === emojiPickerModal) {
      emojiPickerModal.style.display = 'none';
    }
  });

  cancelEmojiBtn.addEventListener('click', () => {
    emojiPickerModal.style.display = 'none';
  });
}

// Show emoji picker for a message
function showEmojiPicker(messageId) {
  currentReactingMessageId = messageId;
  emojiPickerModal.style.display = 'flex';
}

// Save message reactions to localStorage
function saveMessageReactions() {
  localStorage.setItem('messageReactions', JSON.stringify(messageReactions));
}

// Load message reactions from localStorage
function loadMessageReactions() {
  const savedReactions = localStorage.getItem('messageReactions');
  if (savedReactions) {
    try {
      messageReactions = JSON.parse(savedReactions);
      console.log('ðŸŽ­ Loaded message reactions:', messageReactions);
    } catch (error) {
      console.error('âŒ Error loading message reactions:', error);
      messageReactions = {};
    }
  } else {
    messageReactions = {};
  }
}

// Update message reactions in UI
function updateMessageReactions(messageId) {
  const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
  if (!messageElement) return;

  // Find or create reactions container
  let reactionsContainer = messageElement.querySelector('.reactions-container');
  if (!reactionsContainer) {
    reactionsContainer = document.createElement('div');
    reactionsContainer.classList.add('reactions-container');
    messageElement.querySelector('.message-bubble').appendChild(reactionsContainer);
  } else {
    reactionsContainer.innerHTML = '';
  }

  // Add reactions if they exist
  if (messageReactions[messageId]) {
    Object.entries(messageReactions[messageId]).forEach(([emoji, users]) => {
      if (users.length > 0) {
        const reaction = document.createElement('div');
        reaction.classList.add('reaction');
        if (users.includes(userId)) {
          reaction.classList.add('self-reacted');
        }

        const emojiSpan = document.createElement('span');
        emojiSpan.textContent = emoji;

        const countSpan = document.createElement('span');
        countSpan.classList.add('reaction-count');
        countSpan.textContent = users.length;

        reaction.appendChild(emojiSpan);
        reaction.appendChild(countSpan);

        // Add click event to toggle reaction
        reaction.addEventListener('click', () => {
          addReactionToMessage(messageId, emoji);
        });

        reactionsContainer.appendChild(reaction);
      }
    });
  }

  // Remove reactions container if no reactions
  if (reactionsContainer.children.length === 0) {
    reactionsContainer.remove();
  }
}

// Start editing a message
function startEditingMessage(messageId, currentText) {
  editingMessageId = messageId;
  input.value = currentText;
  input.focus();
  sendButton.textContent = 'Update';

  // Add a cancel button temporarily
  if (!document.getElementById('cancel-edit-btn')) {
    const cancelBtn = document.createElement('button');
    cancelBtn.id = 'cancel-edit-btn';
    cancelBtn.textContent = 'Cancel';
    cancelBtn.type = 'button';
    cancelBtn.style.backgroundColor = '#a0aec0';
    cancelBtn.addEventListener('click', cancelEditing);
    form.appendChild(cancelBtn);
  }
}

// Cancel editing
function cancelEditing() {
  editingMessageId = null;
  input.value = '';
  sendButton.textContent = 'Send';

  // Remove cancel button
  const cancelBtn = document.getElementById('cancel-edit-btn');
  if (cancelBtn) {
    cancelBtn.remove();
  }
}

// Update message in database
async function updateMessage(messageId, newText) {
  try {
    // Update the message in the database using PATCH
    const { data, error } = await serverFetch(currentServer, `messages?id=eq.${messageId}`, {
      method: 'PATCH',
      body: JSON.stringify({
        text: newText,
        edited_at: new Date().toISOString()
      })
    });

    if (error) throw new Error('Failed to update message');

    // Update the message in local state
    const messageIndex = allMessages.findIndex(msg => msg.id === messageId);
    if (messageIndex !== -1) {
      allMessages[messageIndex].text = newText;
      allMessages[messageIndex].edited_at = new Date().toISOString();
    }

    // Update server storage
    Object.keys(serverMessages).forEach(server => {
      updateMessageInServer(server, {
        ...allMessages[messageIndex],
        text: newText,
        edited_at: new Date().toISOString()
      });
    });

    // Update the message in UI
    const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
    if (messageElement) {
      const messageDiv = messageElement.querySelector('.message');
      const nameDiv = messageElement.querySelector('.sender-name');
      
      // Update message text
      messageDiv.textContent = newText;
      
      // Update timestamp to show edited
      const displayName = nameDiv.textContent.split(' â€¢ ')[0];
      const editedText = ' - Edited';
      nameDiv.textContent = `${displayName} â€¢ ${formatTime(new Date().toISOString())}${editedText}`;
    }

    showSuccess('Message updated!');
    cancelEditing(); // Remove cancel button after successful edit
    return data;
  } catch (error) {
    console.error('Error updating message:', error);
    showError('Failed to update message. Please try again.');
    throw error;
  }
}

// Update message in server storage
function updateMessageInServer(server, updatedMessage) {
  if (serverMessages[server]) {
    const index = serverMessages[server].findIndex(msg => msg.id === updatedMessage.id);
    if (index !== -1) {
      serverMessages[server][index] = updatedMessage;
      saveServerMessages(server, serverMessages[server]);
      console.log(`âœï¸ Updated message in server ${server}`);
    }
  }
}

// Delete message function
async function deleteMessage(messageId) {
  if (!confirm('Are you sure you want to delete this message?')) return;

  try {
    const { error } = await serverFetch(currentServer, `messages?id=eq.${messageId}`, {
      method: 'DELETE'
    });

    if (error) throw new Error('Failed to delete message');

    // Remove from local state
    allMessages = allMessages.filter(msg => msg.id !== messageId);

    // Remove from UI
    const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
    if (messageElement) messageElement.remove();

    // Remove from server storage
    Object.keys(serverMessages).forEach(server => {
      removeMessageFromServer(server, messageId);
    });

    // Remove reactions for this message
    if (messageReactions[messageId]) {
      delete messageReactions[messageId];
      saveMessageReactions();
    }

    showTemporaryStatus('âœ… Message deleted!');
    showSuccess('Message deleted!');
  } catch (error) {
    console.error('Error deleting message:', error);
    showError('Failed to delete message. Please try again.');
  }
}

// Remove message from server storage
function removeMessageFromServer(server, messageId) {
  if (serverMessages[server]) {
    serverMessages[server] = serverMessages[server].filter(msg => msg.id !== messageId);
    saveServerMessages(server, serverMessages[server]);
    console.log(`âž– Removed message from server ${server}, total messages: ${serverMessages[server].length}`);
  }
}

// Audio call functions (simplified for demo)
function startAudioCall(targetUserId, targetUserName, targetUserAvatar) {
  console.log(`ðŸ“ž Starting audio call with ${targetUserName}...`);
  showError('Audio call functionality is not fully implemented in this demo');
}

function acceptIncomingCall() {
  console.log('ðŸ“ž Accepting incoming call...');
  showError('Audio call functionality is not fully implemented in this demo');
}

function rejectIncomingCall() {
  console.log('ðŸ“ž Rejecting incoming call...');
  incomingCallModal.style.display = 'none';
}

function endAudioCall() {
  console.log('ðŸ“ž Ending audio call...');
  audioCallContainer.style.display = 'none';
  incomingCallModal.style.display = 'none';
  isInCall = false;
  isCallInitiator = false;
  callTargetUserId = null;
  callTargetUserName = null;
  callTargetUserAvatar = null;
}

async function requestMicrophonePermission() {
  try {
    microphonePermissionModal.style.display = 'none';

    // Check if we already have permission
    const permissionStatus = await navigator.permissions.query({ name: 'microphone' });
    if (permissionStatus.state === 'granted') {
      return true;
    }

    // Try to get microphone access
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    stream.getTracks().forEach(track => track.stop()); // Stop immediately, we just needed permission

    showSuccess('Microphone access granted!');
    return true;
  } catch (error) {
    console.error('âŒ Microphone permission denied:', error);
    showError('Microphone access is required for audio calls.');
    return false;
  }
}

// Initialize the app
async function initApp() {
  console.log('ðŸš€ Initializing Enhanced Encrypted Super Chat...');

  try {
    // Initialize user
    initializeUser();
    addNameChangeFeature();

    // Initialize sidebar
    initializeSidebar();

    // Initialize profile pictures
    initializeProfilePictures();

    // Initialize audio call functionality
    initializeAudioCall();

    // Initialize file upload
    initializeFileUpload();

    // Initialize GIF & Sticker functionality
    initializeGifSticker();

    // Initialize emoji picker
    initializeEmojiPicker();

    // Initialize link sharing
    initializeLinkSharing();

    // Initialize text formatting
    initializeTextFormatting();

    // Initialize game modals with enhanced features
    initializeGameModals();

    // Initialize admin panel
    initializeAdminPanel();

    // Initialize adblocker
    initializeAdblocker();

    // Load message reactions
    loadMessageReactions();

    // Load saved wallpaper
    const savedWallpaper = localStorage.getItem("chatWallpaper");
    if (savedWallpaper) {
      applyWallpaper(savedWallpaper);
    }

    // Populate wallpaper options
    wallpapers.forEach(w => {
      const wallpaperContainer = document.createElement("div");
      wallpaperContainer.classList.add("wallpaper-grid");

      const div = document.createElement("div");
      div.classList.add("wallpaper-option");
      div.style.background = w.preview;

      const label = document.createElement("div");
      label.classList.add("wallpaper-label");
      label.textContent = w.name;

      div.addEventListener("click", () => {
        applyWallpaper(w.preview);
        wallpaperModal.style.display = "none";
        showSuccess(`Background changed to ${w.name}!`);
      });

      wallpaperContainer.appendChild(div);
      wallpaperContainer.appendChild(label);
      wallpaperOptions.appendChild(wallpaperContainer);
    });

    // Wallpaper modal logic
    editWallpaperBtn.addEventListener("click", () => {
      wallpaperModal.style.display = "flex";
    });

    wallpaperModal.addEventListener("click", (e) => {
    if (e.target === wallpaperModal) {
      wallpaperModal.style.display = "none";
    }
    });

    // Encryption key modal event listeners
    encryptionKeyModal.addEventListener("click", (e) => {
      if (e.target === encryptionKeyModal) {
        encryptionKeyModal.style.display = "none";
      }
    });

    enterKeyModal.addEventListener("click", (e) => {
      if (e.target === enterKeyModal) {
        enterKeyModal.style.display = "none";
      }
    });

    // Call user modal event listener
    callUserModal.addEventListener("click", (e) => {
      if (e.target === callUserModal) {
        callUserModal.style.display = "none";
      }
    });

    // Microphone permission modal event listener
    microphonePermissionModal.addEventListener("click", (e) => {
      if (e.target === microphonePermissionModal) {
        microphonePermissionModal.style.display = "none";
      }
    });

    // Link share modal event listener
    linkShareModal.addEventListener("click", (e) => {
      if (e.target === linkShareModal) {
        linkShareModal.style.display = 'none';
      }
    });

    // Security indicator click to manage key
    securityIndicator.addEventListener("click", showCurrentKey);

    // Load messages for current server
    loadServerMessages(currentServer);
    await loadMessages();

    // Setup message read tracking
    setupMessageReadTracking();

    // Start polling for new messages
    startPolling();

    console.log('âœ… Encrypted Super Chat initialized successfully');
    showTemporaryStatus('âœ… Encrypted Super Chat ready!');

  } catch (error) {
    console.error('âŒ App initialization failed:', error);
    showError('Failed to initialize. Please refresh the page.');
  }
}

// Show current key (for management)
function showCurrentKey() {
  // Generate a real production encryption key
  const productionKey = encryption.generateProductionKey();
  encryptionKeyDisplay.textContent = productionKey;
  encryptionKeyModal.style.display = 'flex';
}

// Start when ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initApp);
} else {
  initApp();
}

// Event listeners
form.addEventListener('submit', async (e) => {
  e.preventDefault();
  const text = input.value.trim();
  if (!text) return;

  try {
    await sendMessage(text);
  } catch (error) {
    // Error handled in sendMessage
  }
});

// Handle page visibility changes
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    clearInterval(pollInterval);
  } else {
    startPolling();
    checkNewMessages();
  }
});

// Set up encryption key buttons
copyKeyBtn.addEventListener('click', () => {
  navigator.clipboard.writeText(encryptionKeyDisplay.textContent)
    .then(() => showSuccess('Encryption key copied to clipboard!'))
    .catch(() => showError('Failed to copy key to clipboard'));
});

enterKeyBtn.addEventListener('click', () => {
  encryptionKeyModal.style.display = 'none';
  enterKeyModal.style.display = 'flex';
});

confirmKeyBtn.addEventListener('click', () => {
  encryptionKeyModal.style.display = 'none';
  showSuccess('Encryption key saved!');
});

cancelKeyBtn.addEventListener('click', () => {
  enterKeyModal.style.display = 'none';
});

useKeyBtn.addEventListener('click', () => {
  const key = encryptionKeyInput.value.trim();
  if (!key) {
    showError('Please enter an encryption key');
    return;
  }
  enterKeyModal.style.display = 'none';
  showSuccess('Encryption key applied!');

    // ==================== AUTO-SCROLL TO BOTTOM ====================

// Auto-scroll to bottom on initial load
function autoScrollToBottom() {
    console.log('ðŸ”½ Auto-scrolling to bottom...');
    
    // Wait a bit for the DOM to be fully rendered
    setTimeout(() => {
        const messagesDiv = document.getElementById('messages');
        if (messagesDiv) {
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            console.log('âœ… Scrolled to bottom');
        }
    }, 500);
}

// Also scroll to bottom when new messages are added
function enhanceScrollToBottom() {
    const originalScrollToBottom = scrollToBottom;
    
    // Override the scrollToBottom function to be more aggressive
    scrollToBottom = function() {
        const messagesDiv = document.getElementById('messages');
        if (messagesDiv) {
            // Use multiple methods to ensure scrolling works
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            
            // Additional scroll methods for compatibility
            setTimeout(() => {
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
                messagesDiv.scrollIntoView(false);
            }, 100);
            
            console.log('ðŸ“œ Scrolling to bottom of messages');
        }
    };
}

// Call auto-scroll on page load
window.addEventListener('load', () => {
    autoScrollToBottom();
    enhanceScrollToBottom();
});

// Also scroll when messages finish loading
setTimeout(autoScrollToBottom, 1000);
setTimeout(autoScrollToBottom, 2000);

// Scroll to bottom when switching servers or DMs
const originalSwitchServer = switchServer;
switchServer = function(server) {
    originalSwitchServer(server);
    setTimeout(autoScrollToBottom, 300);
};

// Scroll to bottom when loading DM messages
const originalLoadDMMessages = loadDMMessages;
loadDMMessages = async function(targetUserId) {
    await originalLoadDMMessages(targetUserId);
    setTimeout(autoScrollToBottom, 300);
};

console.log('âœ… Auto-scroll functionality added');
});</script>
